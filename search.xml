<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>串口通信</title>
      <link href="/2024/11/04/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/11/04/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>串口通信是指外设和计算机间，通过数据信号线、地线、控制线等，按位进行传输数据的方式。串口通信的特点是高速、低延迟、可靠、可控。串口通信的应用场景有很多，如串口打印机、串口扫描仪、串口电子元器件、串口通讯模块、串口电脑控制、串口通讯终端等。串口通信方式常见的有UART、RS232、RS485、RS422等。</p><h2 id="TTL电平接口"><a href="#TTL电平接口" class="headerlink" title="TTL电平接口"></a>TTL电平接口</h2><p>TTL即晶体管-晶体管逻辑，最常见的就是从MCU（主控芯片）产生。TTL电平接口的特点是高电平有效、低电平无效，数据位为二进制。</p><h2 id="RS232接口"><a href="#RS232接口" class="headerlink" title="RS232接口"></a>RS232接口</h2><p>RS232接口是串行接口，属于标准接口，由两根串行电缆组成，一根为数据线（DTR、RTS），一根为地线（GND）。MCU和一些应用模块通信通常都是TTL电平。电脑，工业设备或者一些模块通常都是232电平，相如DB9接口。传输距离最长15米，只能连一个设备。</p><h2 id="RS485接口"><a href="#RS485接口" class="headerlink" title="RS485接口"></a>RS485接口</h2><p>RS485采用差分信号负逻辑，逻辑”1”以两线间的电压差为+(2<del>6)V表示；逻辑”0”以两线间的电压差为-(2</del>6)V表示。所以原来一条线能表示的信号，现在需要两条线才能表示。所以RS485通信是半双工的。传输距离最长1200米，可以连32个设备。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt事件</title>
      <link href="/2024/09/13/Qt/Qt%E4%BA%8B%E4%BB%B6/"/>
      <url>/2024/09/13/Qt/Qt%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>从用户操作开始，Qt 事件传递的全过程可以从硬件输入（如鼠标点击、键盘输入）到事件处理的每个步骤进行详细描述。以下是从用户操作开始，Qt 的事件传递过程：</p><h3 id="1-用户操作触发硬件事件"><a href="#1-用户操作触发硬件事件" class="headerlink" title="1. 用户操作触发硬件事件"></a>1. 用户操作触发硬件事件</h3><p>用户在图形界面上执行某种操作，如点击按钮、键盘输入、鼠标移动等，这会生成硬件事件。这些事件首先由操作系统捕捉并处理。</p><h3 id="2-操作系统处理并生成系统事件"><a href="#2-操作系统处理并生成系统事件" class="headerlink" title="2. 操作系统处理并生成系统事件"></a>2. 操作系统处理并生成系统事件</h3><p>操作系统（例如 Windows、macOS、Linux 等）捕捉到硬件事件后，会将其封装成系统级别的事件，并通知正在运行的应用程序。</p><h3 id="3-Qt-接收系统事件"><a href="#3-Qt-接收系统事件" class="headerlink" title="3. Qt 接收系统事件"></a>3. Qt 接收系统事件</h3><p>Qt 应用程序通过底层的系统 API 接收来自操作系统的事件。Qt 内部会将这些系统事件转换为 Qt 事件（<code>QEvent</code> 对象）以便在 Qt 事件系统中处理。</p><ul><li>例如，鼠标点击操作会被转换为 <code>QMouseEvent</code>，键盘输入会被转换为 <code>QKeyEvent</code>，窗口操作会被转换为 <code>QResizeEvent</code> 或 <code>QCloseEvent</code> 等。</li></ul><h3 id="4-事件入队列"><a href="#4-事件入队列" class="headerlink" title="4. 事件入队列"></a>4. 事件入队列</h3><p>事件被转换为 <code>QEvent</code> 对象后，Qt 将该事件投递到事件队列中。这一步通过调用 <code>QApplication::postEvent()</code> 完成，事件会暂时存储在事件队列中，等待处理。</p><h3 id="5-事件循环（QEventLoop）"><a href="#5-事件循环（QEventLoop）" class="headerlink" title="5. 事件循环（QEventLoop）"></a>5. 事件循环（<code>QEventLoop</code>）</h3><p>在 Qt 应用程序的主循环中，<code>QApplication::exec()</code> 负责管理事件循环。事件循环会从事件队列中不断取出事件，依次进行分发和处理。</p><p>事件循环的作用是确保应用程序持续响应用户操作和其他系统事件，即使没有事件发生，主循环也会持续运行，保持程序的流畅性。</p><h3 id="6-事件分发（QApplication-notify-）"><a href="#6-事件分发（QApplication-notify-）" class="headerlink" title="6. 事件分发（QApplication::notify()）"></a>6. 事件分发（<code>QApplication::notify()</code>）</h3><p>当事件被取出时，<code>QApplication::notify()</code> 方法负责将事件分发给目标对象（通常是用户操作所作用的窗口部件或控件）。</p><ul><li><strong>目标对象的确定</strong>：每个事件都有一个目标对象，这通常是事件发生时的窗口或控件。例如，用户点击了一个按钮，则该按钮就是事件的目标对象。</li><li><strong>事件传播路径</strong>：如果目标对象未处理该事件，事件会向上传递给该对象的父对象，依次类推，直到找到处理该事件的对象或到达根对象。</li></ul><h3 id="7-目标对象处理事件"><a href="#7-目标对象处理事件" class="headerlink" title="7. 目标对象处理事件"></a>7. 目标对象处理事件</h3><p>一旦事件被分发给目标对象，Qt 会调用目标对象的 <code>event()</code> 方法或更具体的事件处理方法，例如 <code>mousePressEvent()</code>、<code>keyPressEvent()</code> 等。这些方法可以被重载，以实现自定义的事件处理逻辑。</p><ul><li><strong>处理事件</strong>：目标对象可以选择处理事件，处理后返回 <code>true</code>，表示事件已处理，事件传播到此结束。</li><li><strong>未处理事件</strong>：如果目标对象没有处理该事件（例如返回 <code>false</code>），事件会继续向父对象传递，直到找到一个处理该事件的对象。</li></ul><h3 id="8-默认处理与事件过滤"><a href="#8-默认处理与事件过滤" class="headerlink" title="8. 默认处理与事件过滤"></a>8. 默认处理与事件过滤</h3><ul><li><p><strong>默认处理</strong>：如果事件没有被处理，Qt 的默认处理机制会接管，通常是通过调用父类的 <code>event()</code> 方法来处理。例如，如果一个窗口部件没有特定的 <code>mousePressEvent()</code> 实现，<code>QWidget</code> 的默认处理器会尝试处理该事件。</p></li><li><p><strong>事件过滤器</strong>：可以通过 <code>installEventFilter()</code> 方法安装事件过滤器，让一个对象可以监控其他对象的事件。在事件到达目标对象之前，事件过滤器有机会截获事件并进行处理或修改。</p></li></ul><h3 id="9-事件处理的结束"><a href="#9-事件处理的结束" class="headerlink" title="9. 事件处理的结束"></a>9. 事件处理的结束</h3><p>一旦事件被处理或忽略，事件传递过程就结束。程序继续运行，等待下一个事件的到来。</p><h3 id="简单流程总结："><a href="#简单流程总结：" class="headerlink" title="简单流程总结："></a>简单流程总结：</h3><ol><li><strong>用户操作</strong>：点击鼠标、按键等操作触发硬件事件。</li><li><strong>系统事件</strong>：操作系统捕捉并生成系统事件。</li><li><strong>Qt 事件</strong>：Qt 将系统事件转换为 <code>QEvent</code> 对象。</li><li><strong>事件入队列</strong>：事件进入 Qt 的事件队列。</li><li><strong>事件循环</strong>：事件循环从队列中取出事件。</li><li><strong>事件分发</strong>：<code>notify()</code> 将事件分发给目标对象。</li><li><strong>事件处理</strong>：目标对象通过 <code>event()</code> 或具体事件处理函数处理事件。</li><li><strong>默认处理和过滤</strong>：未处理的事件按默认机制处理或通过事件过滤器拦截。</li><li><strong>事件处理结束</strong>：事件处理完成，系统继续监听新的事件。</li></ol><p>这个过程的核心在于 Qt 的事件循环系统，它确保应用能够持续响应用户的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt上下左右中</title>
      <link href="/2024/09/13/Qt/Qt%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E4%B8%AD/"/>
      <url>/2024/09/13/Qt/Qt%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qtdemo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2024/09/12/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2024/09/12/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="1-什么是智能指针"><a href="#1-什么是智能指针" class="headerlink" title="1. 什么是智能指针"></a>1. 什么是智能指针</h2><ol><li>智能指针是一种类模板，它能够自动管理堆上资源的生命周期，从而避免内存泄漏和资源泄露问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UI设计</title>
      <link href="/2024/09/10/Qt/UI%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/09/10/Qt/UI%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="布局-Layou"><a href="#布局-Layou" class="headerlink" title="布局 Layou"></a>布局 Layou</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>可以把布局看作是一个透明的盒子，内部的组件会按照布局预设的规则自动排布。<br>垂直布局：组件从上到下依次排列；<br>水平布局：组件从左到右依次排列；<br>网格布局：组件按照网格的形式排列；<br>表单布局：用于设计输入类页面；</p></blockquote><h1 id="UI指针"><a href="#UI指针" class="headerlink" title="UI指针"></a>UI指针</h1><blockquote><p>创建一个带ui文件的Qt项目，项目中的Dialog类中有一个成员变量：ui指针，个人认为ui指针指向的对象就是该Dialog的UI设计文件，可以通过ui指针在代码中管理界面文件中的对象。<br>[在Designer中设计界面]-&gt;[自动生成xml文件]-&gt;[C++代码开始执行，构造函数中创建ui指针对象]-&gt;[ui-&gt;setupUi(this);解析xml，C++开始创建并初始化]-&gt;[在C++代码中通过ui指针对象管理界面中的对象]-&gt;[在C++代码中修改界面中的对象属性]-&gt;[析构函数销毁ui指针对象的同时一并销毁界面文件中的所有对象]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信号槽</title>
      <link href="/2024/09/10/Qt/%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
      <url>/2024/09/10/Qt/%E4%BF%A1%E5%8F%B7%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="信号槽"><a href="#信号槽" class="headerlink" title="信号槽"></a>信号槽</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>信号槽是一种在 Qt 编程中常用的机制，用于实现对象间的通信。信号是一种事件通知机制，它是一种从对象发送到另一个对象的方法。槽是一种从对象接收到信号的方法。</p><h2 id="使用信号槽的先决条件"><a href="#使用信号槽的先决条件" class="headerlink" title="使用信号槽的先决条件"></a>使用信号槽的先决条件</h2><ul><li>通信的对象必须是 QObject 类型的对象。</li><li>类中要有Q_OBJECT宏，以便支持信号和槽机制。</li></ul><h2 id="信号槽的连接"><a href="#信号槽的连接" class="headerlink" title="信号槽的连接"></a>信号槽的连接</h2><p>信号槽的连接是通过调用connect()函数来实现的。connect()函数的第一个参数是信号，第二个参数是槽。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signalName</span>()), receiver, <span class="built_in">SLOT</span>(<span class="built_in">slotName</span>()));</span><br></pre></td></tr></table></figure><ul><li>sender是信号的发送者，signalName()是信号的名称。</li><li>receiver是槽的接收者，slotName()是槽的名称。</li></ul><h2 id="信号槽的触发"><a href="#信号槽的触发" class="headerlink" title="信号槽的触发"></a>信号槽的触发</h2><p>信号的触发是通过调用emit()函数来实现的。emit()函数的唯一参数是信号的名称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">emit <span class="title">signalName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="信号槽的传递参数"><a href="#信号槽的传递参数" class="headerlink" title="信号槽的传递参数"></a>信号槽的传递参数</h2><p>信号槽可以传递参数。参数可以是基本数据类型，也可以是自定义类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signalName</span>(<span class="type">int</span>, QString)), receiver, <span class="built_in">SLOT</span>(<span class="built_in">slotName</span>(<span class="type">int</span>, QString)));</span><br><span class="line"><span class="function">emit <span class="title">signalName</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>理论上可以传递任意多个参数。</li><li>参数的类型必须匹配。</li><li>信号的参数个数必须大于等于槽的参数个数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象(三)</title>
      <link href="/2024/09/04/C++/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%89/"/>
      <url>/2024/09/04/C++/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote><p>继承是面向对象编程的一个重要概念，它允许创建新的类，从现有类中派生出新的类，并扩展其功能。继承可以使得代码更加简洁，更易于维护和扩展。</p></blockquote><h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><blockquote><p>被继承的类称为基类（base class），派生出来的类称为派生类（derived class）。派生类继承了基类的所有属性和方法，并可以添加自己的属性和方法。</p></blockquote><p>继承的语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 基类名 : <span class="keyword">public</span> 基类所在的命名空间::基类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类中的属性和方法</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 基类中的保护属性和方法</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 基类中的私有属性和方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 派生类名 : <span class="keyword">public</span> 基类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类中的属性和方法</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 派生类中的保护属性和方法</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 派生类中的私有属性和方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>函数隐藏：当一个派生类中有与基类同名的成员函数时，基类的同名函数在派生类中被隐藏，派生类调用该函数时，只会调用派生类中的版本，而无法访问基类的函数。即使基类函数和派生类函数的参数列表不同，基类的所有重载函数都会被隐藏。但可以通过命名空间来访问基类的函数。</p></blockquote><h2 id="派生类和基类构造函数"><a href="#派生类和基类构造函数" class="headerlink" title="派生类和基类构造函数"></a>派生类和基类构造函数</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承和多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL库</title>
      <link href="/2024/09/02/C++/STL%E5%BA%93/"/>
      <url>/2024/09/02/C++/STL%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h1><h2 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h2><p>STL（Standard Template Library，标准模板库）是一系列基于模板的容器、算法和函数的集合，是C++语言的核心库。它提供了高效的算法和数据结构，并可用于开发各种应用。</p><h2 id="STL的组成"><a href="#STL的组成" class="headerlink" title="STL的组成"></a>STL的组成</h2><p>STL由以下几个部分组成：</p><ol><li><p>容器：STL容器是存放数据的地方，包括数组、向量、链表、队列、栈、优先队列、哈希表、集合、映射等。</p></li><li><p>算法：STL算法是对容器中的数据进行操作的函数集合。</p></li><li><p>迭代器：STL迭代器是用来遍历容器中的元素的一种机制。</p></li><li><p>适配器：STL适配器是用来将一种数据结构转换成另一种数据结构的机制。</p></li><li><p>空间：STL空间是用来管理内存的机制。</p></li></ol><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><blockquote><p>容器就是用来存储数据的集合，数据元素可以是任何类型</p></blockquote><h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><blockquote><p>顺序容器中的每个元素均有固定的位置并呈线性排布，除非使用插入或删除操作，否则元素的位置不会改变。</p></blockquote><h4 id="array数组"><a href="#array数组" class="headerlink" title="array数组"></a>array数组</h4><blockquote><p>C++11引入了array容器，可以替代传统数组。array是一个固定大小的数组，只能存放特定类型的数据，不能改变大小。相对于传统数组相对更加安全，易于使用。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个长度为5的int数组</span></span><br><span class="line">    array&lt;<span class="type">int</span>,5&gt; arr = &#123;<span class="number">1</span>,<span class="number">54</span>,<span class="number">3</span>&#125;; <span class="comment">// 后面两位补零</span></span><br><span class="line">    cout &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; arr[<span class="number">4</span>] &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐使用</span></span><br><span class="line">    cout &lt;&lt; arr.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    arr[<span class="number">3</span>] = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector向量"><a href="#vector向量" class="headerlink" title="vector向量"></a>vector向量</h4><blockquote><p>vector是一个动态数组，可以存放不同类型的数据，可以改变大小；擅长存取操作，但不擅长插入和删除操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//    vector&lt;int&gt; v = &#123;1,2,3&#125;;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; v.size() &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    for(int i : v)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个长度为5的int向量</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">//    for(int i : vec)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">222</span>);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; vec.size() &lt;&lt; endl; // 6</span></span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>()<span class="number">+2</span>,<span class="number">333</span>);  <span class="comment">// begin()可以返回指向第一个元素的迭代器指针，+2是在第三个位置上插入333</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    vec.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">111</span>;</span><br><span class="line">    vec[<span class="number">1</span>] = <span class="number">222</span>;</span><br><span class="line">    vec.<span class="built_in">at</span>(<span class="number">3</span>) = <span class="number">444</span>;</span><br><span class="line">    vec.<span class="built_in">at</span>(<span class="number">4</span>) = <span class="number">555</span>;</span><br><span class="line">    vec.<span class="built_in">at</span>(<span class="number">5</span>) = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()<span class="number">+1</span>);   <span class="comment">// 删除第二个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">end</span>()<span class="number">-2</span>); <span class="comment">// 删除倒数第二个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    cout &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vec.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器遍历，先省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空，1空，0就是非空</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">empty</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">empty</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list链表"><a href="#list链表" class="headerlink" title="list链表"></a>list链表</h4><blockquote><p>list是一个双向链表，可以存放不同类型的数据，可以改变大小；擅长插入和删除操作，但不擅长存取操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//    // 创建了一个默认无数值的list</span></span><br><span class="line">    <span class="comment">//    list&lt;string&gt; lis1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    // 创建一个长度为2的列表，第一个元素hello，第二个元素world</span></span><br><span class="line">    <span class="comment">//    list&lt;string&gt; lis2&#123;&quot;hello&quot;,&quot;world&quot;&#125;;</span></span><br><span class="line">    <span class="comment">//    for(string s : lis2)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个长度为5的列表，每个元素都是hello</span></span><br><span class="line">    list&lt;string&gt;<span class="built_in">lis</span>(<span class="number">5</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    lis.<span class="built_in">push_back</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// 向后追加单元素</span></span><br><span class="line">    lis.<span class="built_in">push_front</span>(<span class="string">&quot;haha&quot;</span>); <span class="comment">// 向前插入单元素</span></span><br><span class="line"></span><br><span class="line">    lis.<span class="built_in">insert</span>(++lis.<span class="built_in">begin</span>(),<span class="string">&quot;222&quot;</span>);    <span class="comment">// 在第二个位置上插入“222”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="comment">// lis.pop_back(); // 删除最后一个元素</span></span><br><span class="line">    lis.<span class="built_in">pop_front</span>();    <span class="comment">// 删除第一个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器操作</span></span><br><span class="line">    <span class="comment">// 保存迭代器指针</span></span><br><span class="line">    list&lt;string&gt;::iterator iter = lis.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(iter,<span class="number">1</span>);    <span class="comment">// 移动迭代器</span></span><br><span class="line">    lis.<span class="built_in">insert</span>(iter,<span class="string">&quot;333&quot;</span>); <span class="comment">// 插入333</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line"><span class="comment">//    iter = lis.end();</span></span><br><span class="line"><span class="comment">//    iter--;</span></span><br><span class="line"><span class="comment">//    lis.erase(iter);</span></span><br><span class="line"></span><br><span class="line">    iter = lis.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(iter,<span class="number">1</span>);</span><br><span class="line">    lis.<span class="built_in">erase</span>(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回第一个元素的引用</span></span><br><span class="line">    cout &lt;&lt; lis.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最后一个元素的引用</span></span><br><span class="line">    cout &lt;&lt; lis.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    iter = lis.<span class="built_in">end</span>();</span><br><span class="line">    <span class="built_in">advance</span>(iter,<span class="number">2</span>);</span><br><span class="line">    *iter = <span class="string">&quot;200&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----&quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持普通循环，因为不支持下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each 可以使用</span></span><br><span class="line">    <span class="keyword">for</span>(string s : lis)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也支持迭代器遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    lis.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; lis.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque双端队列"><a href="#deque双端队列" class="headerlink" title="deque双端队列"></a>deque双端队列</h4><blockquote><p>deque是一种双端队列，可以从两端插入和删除元素，最擅长两端的存取操作。性能位于vector和list之间，几乎支持所有vector的操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//    deque&lt;int&gt; v = &#123;1,2,3&#125;;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; v.size() &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    for(int i : v)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个长度为5的int向量</span></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">//    for(int i : deq)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    deq.<span class="built_in">push_back</span>(<span class="number">222</span>);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; deq.size() &lt;&lt; endl; // 6</span></span><br><span class="line"></span><br><span class="line">    deq.<span class="built_in">insert</span>(deq.<span class="built_in">begin</span>()<span class="number">+2</span>,<span class="number">333</span>);  <span class="comment">// begin()可以返回指向第一个元素的迭代器指针，+2是在第三个位置上插入333</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    deq.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">111</span>;</span><br><span class="line">    deq[<span class="number">1</span>] = <span class="number">222</span>;</span><br><span class="line">    deq.<span class="built_in">at</span>(<span class="number">3</span>) = <span class="number">444</span>;</span><br><span class="line">    deq.<span class="built_in">at</span>(<span class="number">4</span>) = <span class="number">555</span>;</span><br><span class="line">    deq.<span class="built_in">at</span>(<span class="number">5</span>) = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    deq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    deq.<span class="built_in">erase</span>(deq.<span class="built_in">begin</span>()<span class="number">+1</span>);   <span class="comment">// 删除第二个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    deq.<span class="built_in">erase</span>(deq.<span class="built_in">end</span>()<span class="number">-2</span>); <span class="comment">// 删除倒数第二个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    cout &lt;&lt; deq[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; deq.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : deq)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; deq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; deq.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器遍历，先省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空，1空，0就是非空</span></span><br><span class="line">    cout &lt;&lt; deq.<span class="built_in">empty</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    deq.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; deq.<span class="built_in">empty</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; deq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h4><blockquote><p>string是一种特殊类型的容器，专门用于存储和操作字符串。<br>string本质是一个类，可以像其他类一样进行构造、拷贝、赋值等操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;   <span class="comment">// 创建一个空字符串</span></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">empty</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>;    <span class="comment">// 隐式调用构造函数</span></span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;     <span class="comment">// 显式调用构造函数</span></span><br><span class="line">    cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (s1 == s2) &lt;&lt; endl; <span class="comment">// ==   0</span></span><br><span class="line">    cout &lt;&lt; (s1 != s2) &lt;&lt; endl; <span class="comment">// !=   1</span></span><br><span class="line">    cout &lt;&lt; (s1 &gt; s2) &lt;&lt; endl;  <span class="comment">// &gt;    0</span></span><br><span class="line">    cout &lt;&lt; (s1 &lt; s2) &lt;&lt; endl;  <span class="comment">// &lt;    1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;      <span class="comment">// string s3 = s2;</span></span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl; <span class="comment">// world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数1：char* 源字符串</span></span><br><span class="line">    <span class="comment">// 参数2：保留的字符数</span></span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(<span class="string">&quot;ABCDEFG&quot;</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s4 &lt;&lt; endl; <span class="comment">// ABC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数1：std::string源字符串</span></span><br><span class="line">    <span class="comment">// 参数2：不保留的字符数，从头开始</span></span><br><span class="line">    <span class="function">string <span class="title">s5</span><span class="params">(s2,<span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s5 &lt;&lt; endl; <span class="comment">// ld</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数1：字符的数量</span></span><br><span class="line">    <span class="comment">// 参数2：字符内容 char</span></span><br><span class="line">    <span class="function">string <span class="title">s6</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s6 &lt;&lt; endl; <span class="comment">// aaaaa</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原 s5 = &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="string">&quot;原 s6 =&quot;</span> &lt;&lt; s6 &lt;&lt; endl; <span class="comment">// 原 s5 = ld原 s6 =aaaaa</span></span><br><span class="line">    <span class="built_in">swap</span>(s5,s6);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s5 = &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="string">&quot;s6 =&quot;</span> &lt;&lt; s6 &lt;&lt; endl;  <span class="comment">// s5 = aaaaas6 =ld</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串连接</span></span><br><span class="line">    string s7 = s5 + s6;</span><br><span class="line">    cout &lt;&lt; s7 &lt;&lt; endl; <span class="comment">// aaaaald</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向后追加字符串</span></span><br><span class="line">    s<span class="number">7.</span><span class="built_in">append</span>(<span class="string">&quot;jiajia&quot;</span>);</span><br><span class="line">    cout &lt;&lt; s7 &lt;&lt; endl; <span class="comment">// aaaaaldjiajia</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向后追加单字符</span></span><br><span class="line">    s<span class="number">7.</span><span class="built_in">push_back</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; s7 &lt;&lt; endl; <span class="comment">// aaaaaldjiajias</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="comment">// 参数1：插入的位置</span></span><br><span class="line">    <span class="comment">// 参数2：插入的内容</span></span><br><span class="line">    s<span class="number">7.</span><span class="built_in">insert</span>(<span class="number">1</span>,<span class="string">&quot;234&quot;</span>);</span><br><span class="line">    cout &lt;&lt; s7 &lt;&lt; endl; <span class="comment">// a234aaaaldjiajias</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除字符串</span></span><br><span class="line">    <span class="comment">// 参数1：起始位置</span></span><br><span class="line">    <span class="comment">// 参数2：删除的字符数量</span></span><br><span class="line">    s<span class="number">7.</span><span class="built_in">erase</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; s7 &lt;&lt; endl; <span class="comment">// a2aldjiajias</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    <span class="comment">// 参数1：起始位置</span></span><br><span class="line">    <span class="comment">// 参数2：被替换的字符数</span></span><br><span class="line">    <span class="comment">// 参数3：替换的新内容</span></span><br><span class="line">    s<span class="number">7.</span><span class="built_in">replace</span>(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&quot;***&quot;</span>);</span><br><span class="line">    cout &lt;&lt; s7 &lt;&lt; endl; <span class="comment">// ***ldjiajias</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    s<span class="number">7.</span><span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; s<span class="number">7.l</span>ength() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式调用构造函数</span></span><br><span class="line">    string s8 = <span class="string">&quot;hahaha&quot;</span>;</span><br><span class="line">    cout &lt;&lt; s8 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新赋值</span></span><br><span class="line">    s8 = <span class="string">&quot;ABCDEFGH&quot;</span>;</span><br><span class="line">    cout &lt;&lt; s8 &lt;&lt; endl; <span class="comment">// ABCDEFGH</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c++的string到C的string也就是数组</span></span><br><span class="line">    <span class="comment">// 参数1：拷贝的目标</span></span><br><span class="line">    <span class="comment">// 参数2：拷贝的字符数量</span></span><br><span class="line">    <span class="comment">// 参数3：拷贝的起始位置</span></span><br><span class="line">    <span class="type">char</span> arr[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    s<span class="number">8.</span><span class="built_in">copy</span>(arr,<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; arr &lt;&lt; endl;    <span class="comment">// BCDEFG</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++string 到 C string 用到了c语言中的strcpy</span></span><br><span class="line">    <span class="comment">// c_str C++的字符串转成C语言的字符数组</span></span><br><span class="line">    <span class="comment">// c_str返回一个const char*</span></span><br><span class="line">    <span class="type">char</span> c[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(c,s<span class="number">8.</span><span class="built_in">c_str</span>());</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><blockquote><p>关联容器是一种特殊的容器，各个元素之间没有严格的顺序关系，可以根据键值来访问元素。</p></blockquote><h4 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h4><blockquote><p>map是一个关联容器，可以存储键值对，键值对的键是唯一的，可以根据键值来访问元素。键常用数字或字符串表示，值可以是任意类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建了一个map容器的对象ma1</span></span><br><span class="line">    <span class="comment">// 列表初始化，C++11支持</span></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; ma1 = &#123;&#123;<span class="string">&quot;年龄&quot;</span>,<span class="number">18</span>&#125;,&#123;<span class="string">&quot;体重&quot;</span>,<span class="number">200</span>&#125;&#125;; <span class="comment">// 有两个元素</span></span><br><span class="line">    cout &lt;&lt; ma<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个元素为0的键值对对象</span></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; ma;</span><br><span class="line">    cout &lt;&lt; ma.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    ma[<span class="string">&quot;身高&quot;</span>] = <span class="number">226</span>; <span class="comment">// 插入元素</span></span><br><span class="line">    ma.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;体重&quot;</span>,<span class="number">300</span>));  <span class="comment">// 插入元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    cout &lt;&lt; ma[<span class="string">&quot;身高&quot;</span>] &lt;&lt; endl;   <span class="comment">// 226</span></span><br><span class="line">    cout &lt;&lt; ma[<span class="string">&quot;体重&quot;</span>] &lt;&lt; endl;   <span class="comment">// 300</span></span><br><span class="line">    <span class="keyword">if</span>(ma.<span class="built_in">find</span>(<span class="string">&quot;身高&quot;</span>) == ma.<span class="built_in">end</span>())   <span class="comment">// find从头开始查找，查找不到返回end</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到身高元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ma[<span class="string">&quot;身高&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    ma[<span class="string">&quot;身高&quot;</span>] = <span class="number">50</span>;  <span class="comment">// 修改元素</span></span><br><span class="line">    cout &lt;&lt; ma[<span class="string">&quot;身高&quot;</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删，删除之前可以判断元素是否存在</span></span><br><span class="line"><span class="comment">//    int re = ma.erase(&quot;身高&quot;);    // 删除成功返回1，失败返回0</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;身高删除的返回值：&quot; &lt;&lt;re &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    re = ma.erase(&quot;身高&quot;);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;身高删除的返回值：&quot; &lt;&lt;re &lt;&lt; endl;   // 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout &lt;&lt; ma.size() &lt;&lt; endl;  // 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    ma.clear();</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; ma.size() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each</span></span><br><span class="line">    <span class="keyword">for</span>(pair&lt;string,<span class="type">int</span>&gt;pa : ma)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; pa.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pa.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><blockquote><p>迭代器是一个特殊的指针，主要用于容器元素的读写以及遍历。<br>如果迭代器不进行修改操作，建议使用只读迭代器<code>const_iterator</code>,反之使用读写迭代器<code>iterator</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="comment">// 迭代器遍历string</span></span><br><span class="line">    <span class="keyword">for</span>(string::const_iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="type">int</span>,5&gt; arr = &#123;<span class="number">23</span>,<span class="number">45</span>,<span class="number">66</span>,<span class="number">22</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(array&lt;<span class="type">int</span>,<span class="number">5</span>&gt;::const_iterator iter = arr.<span class="built_in">begin</span>();iter != arr.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;string&gt;<span class="built_in">vec</span>(<span class="number">6</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;string&gt;::const_iterator iter = vec.<span class="built_in">begin</span>();iter != vec.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">list&lt;string&gt; <span class="title">lis</span><span class="params">(<span class="number">6</span>,<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;string&gt;::const_iterator iter = lis.<span class="built_in">begin</span>();iter != lis.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;string&gt;<span class="built_in">de</span>(<span class="number">6</span>,<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;string&gt;::const_iterator iter = de.<span class="built_in">begin</span>();iter != de.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; ma;</span><br><span class="line">    ma[<span class="string">&quot;年龄&quot;</span>] = <span class="number">20</span>;</span><br><span class="line">    ma[<span class="string">&quot;身高&quot;</span>] = <span class="number">185</span>;</span><br><span class="line">    ma[<span class="string">&quot;体重&quot;</span>] = <span class="number">75</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(map&lt;string,<span class="type">int</span>&gt;::const_iterator iter = ma.<span class="built_in">begin</span>(); iter != ma.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// first 是键，second是值</span></span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL标准库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模板</title>
      <link href="/2024/09/02/C++/C-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/09/02/C++/C-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="C-模板"><a href="#C-模板" class="headerlink" title="C++模板"></a>C++模板</h1><h2 id="1-什么是模板"><a href="#1-什么是模板" class="headerlink" title="1. 什么是模板"></a>1. 什么是模板</h2><p>模板是C++中一种代码复用技术，它允许用户定义一个模板，然后在程序中多次使用这个模板，从而节省时间和代码量。模板可以定义类、函数、变量，甚至可以定义运算符。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板可以定义一个函数，其参数可以是任意类型，而不是具体的类型，以便在程序中多次使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   <span class="comment">// 可以是class也可以是typename</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;20&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板可以定义一个类，其成员变量和成员函数可以是任意类型，而不是具体的类型，以便在程序中多次使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   <span class="comment">// 可以是class也可以是typename</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   <span class="comment">// 可以是class也可以是typename</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T v):<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get_val</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_val</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Test t1(20);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; t1.get_val() &lt;&lt; endl;</span></span><br><span class="line">    <span class="function">Test&lt;<span class="type">int</span>&gt; <span class="title">t1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span><span class="built_in">get_val</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">set_val</span>(<span class="number">2.354</span>);</span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span><span class="built_in">get_val</span>() &lt;&lt; endl;   <span class="comment">// 数据窄化输出2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Test&lt;<span class="type">double</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">0.2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; t<span class="number">2.</span><span class="built_in">get_val</span>() &lt;&lt; endl;   <span class="comment">// 0.2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Test&lt;string&gt; <span class="title">t3</span><span class="params">(<span class="string">&quot;你好&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; t<span class="number">3.</span><span class="built_in">get_val</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类内声明类外定义"><a href="#类内声明类外定义" class="headerlink" title="类内声明类外定义"></a>类内声明类外定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   <span class="comment">// 可以是class也可以是typename</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   <span class="comment">// 可以是class也可以是typename</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T v);</span><br><span class="line">    <span class="function">T <span class="title">get_val</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_val</span><span class="params">(<span class="type">const</span> T &amp;val)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Test&lt;T&gt;::<span class="built_in">Test</span>(T v):<span class="built_in">val</span>(v)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Test&lt;T&gt;::<span class="built_in">get_val</span>()<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Test&lt;T&gt;::<span class="built_in">set_val</span>(<span class="type">const</span> T &amp;val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Test t1(20);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; t1.get_val() &lt;&lt; endl;</span></span><br><span class="line">    <span class="function">Test&lt;<span class="type">int</span>&gt; <span class="title">t1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span><span class="built_in">get_val</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">set_val</span>(<span class="number">2.354</span>);</span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span><span class="built_in">get_val</span>() &lt;&lt; endl;   <span class="comment">// 数据窄化输出2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Test&lt;<span class="type">double</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">0.2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; t<span class="number">2.</span><span class="built_in">get_val</span>() &lt;&lt; endl;   <span class="comment">// 0.2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Test&lt;string&gt; <span class="title">t3</span><span class="params">(<span class="string">&quot;你好&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; t<span class="number">3.</span><span class="built_in">get_val</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看出<code>template&lt;class T&gt;</code>的作用域只有声明之后的第一个<code>&#123;&#125;</code>中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象(二)</title>
      <link href="/2024/09/02/C++/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BA%8C/"/>
      <url>/2024/09/02/C++/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="友元概念"><a href="#友元概念" class="headerlink" title="友元概念"></a>友元概念</h3><blockquote><p>类实现了数据的隐藏和封装，类的数据成员一般定义为私有成员，仅能通过类的成员函数才能读写。如果数据成员定义为公共的，则又破坏了封装性。但是在某些情况下，需要频繁读写类的数据成员，特别是在对某些成员函数多次调用时，由于参数传递，类型检查和安全性检查等都需要时间开销。影响程序的运行效率。</p></blockquote><h3 id="友元的实现："><a href="#友元的实现：" class="headerlink" title="友元的实现："></a>友元的实现：</h3><blockquote><ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul></blockquote><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul><li>声明友元函数：在类声明中，使用关键字<code>friend</code>声明友元函数，并在函数声明中添加<code>friend</code>关键字。</li><li>定义友元函数：在类定义中，在函数定义前加上<code>friend</code>关键字，并在函数定义中添加<code>friend</code>关键字。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; a = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printA</span><span class="params">(A obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; obj.a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    obj.<span class="built_in">setA</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printA</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>友元函数没有this指针。</li><li>友元函数的声明可以放置在类的任何位置，不受权限描述符的限制。</li><li>一个友元函数理论上可以访问多个类，只要在各个类中分别声明。</li></ul></blockquote><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><ul><li><p>声明友元类：在类声明中，使用关键字<code>friend</code>声明友元类，并在类声明中添加<code>friend</code>关键字。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; a = x; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; b = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    obj.<span class="built_in">setA</span>(<span class="number">10</span>);</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">setB</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意：</strong></p><ul><li>友元关系不能被继承。</li><li>友元关系不具有交换性，属于是单向给予的关系。（例：类A声明友元类B，B类可以访问A类的私有成员，但A类不能访问B类的私有成员）</li><li>互为友元需要相互声明。</li></ul></blockquote><h3 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h3><blockquote><p>使类B中的成员函数成为类Test的友元成员函数，这样类B的该成员函数就可以访问类Test的所有成员了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步：声明被访问的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 第二步：声明友元成员函数（类内声明，类外实现）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">and_test</span><span class="params">(Test &amp;t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> i):<span class="built_in">a</span>(i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元成员函数，类内声明：第一步确定友元成员函数的格式并声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span>  <span class="type">void</span> <span class="title">B::and_test</span><span class="params">(Test &amp;t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步：类外定义友元成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::and_test</span><span class="params">(Test &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ++t.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;t.a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">and_test</span>(t1);</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="运算符重载"></a><strong>运算符重载</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>运算符预定义的操作只能针对基本数据类型，但对于自定义类型，也需要类似的操作。运算符重载就是在自定义类型上重新定义运算符的功能，以实现对自定义类型的操作。<br><img src="https://s2.loli.net/2024/09/02/sY4kfBHlh1bINcr.png" alt=".png"><br>能重载的实在是太多了，所以记不能重载的：</p><ul><li>成员访问运算符（<code>.</code>）</li><li>条件运算符（<code>?:</code>）</li><li>sizeof</li><li>作用域运算符（<code>::</code>）</li></ul></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><blockquote><ul><li>友元函数运算符重载</li><li>成员函数运算符重载</li></ul></blockquote><h3 id="友元函数运算符重载"><a href="#友元函数运算符重载" class="headerlink" title="友元函数运算符重载"></a>友元函数运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> a):<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// + 运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyInt <span class="keyword">operator</span>+(MyInt &amp;i,MyInt &amp;i2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyInt <span class="keyword">operator</span>+ (MyInt &amp;i,MyInt &amp;i2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    MyInt int4(0);</span></span><br><span class="line"><span class="comment">//    int4.a = i.a + i2.a;</span></span><br><span class="line"><span class="comment">//    return int4;</span></span><br><span class="line">    <span class="keyword">return</span> i.a + i<span class="number">2.</span>a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyInt <span class="title">int1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">1.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="function">MyInt <span class="title">int2</span><span class="params">(int1)</span></span>;   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">2.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    MyInt int3 = int1 + int2;</span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">3.</span><span class="built_in">get_int</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>++运算符重载：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> a):<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// + 运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyInt <span class="keyword">operator</span>+(MyInt &amp;i,MyInt &amp;i2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++ 运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyInt <span class="keyword">operator</span> ++(MyInt &amp;i); <span class="comment">// 前置自增</span></span><br><span class="line">    <span class="keyword">friend</span> MyInt <span class="keyword">operator</span> ++(MyInt &amp;i,<span class="type">int</span>); <span class="comment">// 后置自增</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyInt <span class="keyword">operator</span>+ (MyInt &amp;i,MyInt &amp;i2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    MyInt int4(0);</span></span><br><span class="line"><span class="comment">//    int4.a = i.a + i2.a;</span></span><br><span class="line"><span class="comment">//    return int4;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i.a + i<span class="number">2.</span>a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyInt <span class="keyword">operator</span> ++(MyInt &amp;i)</span><br><span class="line">&#123;</span><br><span class="line">    ++i.a;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyInt <span class="keyword">operator</span> ++(MyInt &amp;i,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i.a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyInt <span class="title">int1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">1.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="function">MyInt <span class="title">int2</span><span class="params">(int1)</span></span>;   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">2.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    MyInt int3 = int1 + int2;</span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">3.</span><span class="built_in">get_int</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ++int1;</span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">1.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (int1++).<span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">1.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里用到了哑元函数，对前置++和后置++进行了区分。</p></blockquote><h3 id="成员函数运算符重载"><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> a):<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// + 运算符重载</span></span><br><span class="line">    MyInt <span class="keyword">operator</span>+(MyInt &amp;i2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++ 运算符重载</span></span><br><span class="line">    MyInt <span class="keyword">operator</span> ++(); <span class="comment">// 前置自增</span></span><br><span class="line">    MyInt <span class="keyword">operator</span> ++(<span class="type">int</span>); <span class="comment">// 后置自增</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyInt MyInt::<span class="keyword">operator</span>+ (MyInt &amp;i2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a + i<span class="number">2.</span>a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyInt MyInt::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ++<span class="keyword">this</span>-&gt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyInt MyInt::<span class="keyword">operator</span> ++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyInt <span class="title">int1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">1.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="function">MyInt <span class="title">int2</span><span class="params">(int1)</span></span>;   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">2.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    MyInt int3 = int1 + int2;</span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">3.</span><span class="built_in">get_int</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ++int1;</span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">1.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (int1++).<span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">1.</span><span class="built_in">get_int</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>成员函数运算符重载相比于友元函数重载，最主要的区别在于，友元函数的第一个输出参数，在成员函数中使用this指针代替，因此同样的运算符重载，成员函数运算符重载比友元函数运算符重载参数少一个。</p></blockquote><h2 id="特殊运算符重载"><a href="#特殊运算符重载" class="headerlink" title="特殊运算符重载"></a>特殊运算符重载</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><blockquote><p>除了之前学习的无参构造函数、拷贝构造函数与析构函数以外，如果程序员不手写，编译器还会给一个类添加赋值运算符重载函数。<br>赋值运算符重载只能使用成员函数运算符重载。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> a):<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译器自动添加的赋值运算符重载函数</span></span><br><span class="line">    MyInt &amp; <span class="keyword">operator</span> =(MyInt &amp;i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值运算符重载函数被调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = i.a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyInt <span class="title">int1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">MyInt <span class="title">int2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyInt int3 = int1;   <span class="comment">// 拷贝构造函数隐式调用</span></span><br><span class="line">    int3 = int2;    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    cout &lt;&lt; <span class="type">int</span><span class="number">3.</span><span class="built_in">get_int</span>() &lt;&lt; endl;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当类中出现指针类型的成员变量时，默认的赋值运算符重载函数类似于默认的浅拷贝构造函数出现的问题。因此也需要手写编写解决”浅拷贝“的问题。</p></blockquote><blockquote><p>所以一个类如果什么都不写，编译器也会给它添加默认的赋值运算符重载函数，如果类中有指针类型的成员变量，则需要手写赋值运算符重载函数。<br>故：类中什么都不写编译器会在类中添加无参构造函数、拷贝构造函数、析构函数、赋值运算符重载函数。</p></blockquote><h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><blockquote><p>类型转换运算符重载函数的作用是将自定义类型转换为其他类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> a):<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译器自动添加的赋值运算符重载函数</span></span><br><span class="line">    MyInt &amp; <span class="keyword">operator</span> =(MyInt &amp;i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值运算符重载函数被调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = i.a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换运算符重载</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyInt <span class="title">int1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = int1;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str  = int1;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类型转换运算符重载函数的声明格式为：<code>operator 类型名()</code>，其中类型名可以是任意有效的类型。</p></blockquote><blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote><blockquote><ul><li>运算符重载是一种在自定义类型上重新定义运算符的功能，以实现对自定义类型的操作。</li><li>重载运算符限制在C++中已有的运算符，不能创建新的运算符</li><li>运算符重载本质上是函数重载，但不支持函数参数默认值设定</li><li>重载之后的运算符不能改变运算符的优先级和结合性；也不能改变运算符的操作数和语法结构。</li><li>运算符重载必须基于或包含自定义类型，不能改变基本类型的运算规则。</li><li>重载的功能应该与原有功能相似，避免无目的的滥用</li><li>一般情况下，双目运算符建议使用友元函数运算符重载，单目运算符建议使用成员函数运算符重载。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象(一)</title>
      <link href="/2024/08/28/C++/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%80/"/>
      <url>/2024/08/28/C++/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>类(Class)：是对一类事物的抽象，是抽象的模板，是用来创建对象的蓝图。它定义了该类对象的属性和行为。</p><p>对象(Object)：是类的实例，是根据类创建出来的一个个具体的事物。对象包含了数据和代码。</p><h2 id="类和对象之间的关系"><a href="#类和对象之间的关系" class="headerlink" title="类和对象之间的关系"></a>类和对象之间的关系</h2><p>类是抽象的模板，它定义了该类对象的属性和行为，对象是根据类创建出来的具体的事物，它包含了数据和代码。</p><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><blockquote><p>类中包含了属性和行为:</p><ul><li>属性：成员变量，类中用于描述对象的特征和状态的变量。</li><li>行为：成员函数，类中用于实现对象的功能的函数。</li></ul></blockquote><h3 id="类的创建语法："><a href="#类的创建语法：" class="headerlink" title="类的创建语法："></a>类的创建语法：</h3><p><img src="https://s2.loli.net/2024/08/28/lRzmY3HsTdQ74pN.png" alt=".png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//私有成员变量</span></span><br><span class="line">        <span class="comment">//私有成员函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//公有成员变量</span></span><br><span class="line">        <span class="comment">//公有成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><blockquote><p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。</p></blockquote><h3 id="C-中存在两种类型的对象："><a href="#C-中存在两种类型的对象：" class="headerlink" title="C++中存在两种类型的对象："></a>C++中存在两种类型的对象：</h3><h4 id="栈内存对象："><a href="#栈内存对象：" class="headerlink" title="栈内存对象："></a>栈内存对象：</h4><blockquote><p>对象所在的{}执行结束后，自动销毁。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;This is a stack memory object&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>栈内存对象对成员变量成员函数的访问用<code>&quot;.&quot;</code>表示，如<code>obj.print()</code>。</p></blockquote><h4 id="堆内存对象："><a href="#堆内存对象：" class="headerlink" title="堆内存对象："></a>堆内存对象：</h4><blockquote><p>对象使用new创建，使用指针保存，需要手动delete销毁，否则会造成内存泄漏。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;This is a heap memory object&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass *obj = <span class="keyword">new</span> MyClass;</span><br><span class="line">    obj-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>堆内存对象对成员变量成员函数的访问用<code>-&gt;&quot; &quot;</code>表示，如<code>obj-&gt;print()</code>。</p></blockquote><h2 id="思考题-malloc-与-new的区别，free与delete区别"><a href="#思考题-malloc-与-new的区别，free与delete区别" class="headerlink" title="思考题: malloc 与 new的区别，free与delete区别"></a>思考题: malloc 与 new的区别，free与delete区别</h2><blockquote><p><code>malloc</code> 和 <code>new</code> 以及 <code>free</code> 和 <code>delete</code> 都是进行内存管理的操作</p><ul><li><code>malloc</code> 和 <code>new</code>的区别：<ul><li><code>malloc</code> 是 C 语言中的函数，用于从堆中分配一块连续的内存块。它返回一个 <code>void* </code>指针，需要手动进行类型转换。malloc 只分配内存，并不负责初始化该内存块。</li><li><code>new</code> 是 C++ 中的操作符，不仅分配内存，还调用对象的构造函数初始化对象。它返回正确类型的指针，因此不需要进行类型转换。</li></ul></li><li><code>free</code> 和 <code>delete</code>的区别：<ul><li><code>free</code> 是 C 语言中的函数，用于释放堆中分配的内存块。</li><li><code>delete</code> 是 C++ 中的操作符，用于释放堆中分配的内存块，并调用对象的析构函数。</li></ul></li></ul></blockquote><h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><ul><li>构造函数是类的成员函数，它在对象创建时被调用，用来初始化对象。</li><li>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br>自定义构造函数后，系统将不再提供默认构造函数。（编译器：你自己都写了还用我的干嘛）</li></ul></blockquote><h3 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h3><blockquote><p>如果没有自定义构造函数，编译器会自动生成一个无参构造函数，该函数会默认初始化所有的成员变量。只不过默认的啥也没有就只是默认初始化。<br>自定义构造函数可以用来为成员变量设置初始值。</p></blockquote><h3 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h3><blockquote><p>有参构造函数是指构造函数带有参数，这些参数可以用来为成员变量设置初始值。<br>有参构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。</p></blockquote><h3 id="构造初始化列表"><a href="#构造初始化列表" class="headerlink" title="构造初始化列表"></a>构造初始化列表</h3><blockquote><p>C++11引入了构造初始化列表，可以为成员变量设置初始值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyClass</span>(<span class="type">int</span> n):<span class="built_in">num</span>(n)&#123;</span><br><span class="line">            <span class="comment">//构造函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><blockquote><p>构造函数的重载是指创建多个构造函数，它们具有相同的函数名，但参数列表不同。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyClass</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">            num = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MyClass</span>(<span class="type">double</span> d)&#123;</span><br><span class="line">            num = (<span class="type">int</span>)d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有两个构造函数，它们具有相同的函数名<code>MyClass</code>，但参数列表不同。<code>MyClass(int n)</code>用于初始化<code>num</code>为整数，<code>MyClass(double d)</code>用于初始化<code>num</code>为浮点数。</p></blockquote><h3 id="构造函数的作用"><a href="#构造函数的作用" class="headerlink" title="构造函数的作用"></a>构造函数的作用</h3><blockquote><p>构造函数的作用是用来初始化对象，为对象设置初始值。</p></blockquote><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><blockquote><ul><li>析构函数是类的成员函数，它在对象销毁时被调用，用来释放对象占用的资源。</li><li>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。<br>未定义析构函数，编译器会自动生成一个默认的析构函数，该函数什么也不做。</li></ul></blockquote><h3 id="析构函数的作用"><a href="#析构函数的作用" class="headerlink" title="析构函数的作用"></a>析构函数的作用</h3><blockquote><p>自定义析构函数可以用来释放对象占用的资源，比如内存、文件句柄等。</p><ul><li>释放资源</li><li>防止内存泄漏</li></ul></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th align="center">构造函数</th><th align="center">析构函数</th></tr></thead><tbody><tr><td align="center">创建对象时手动调用</td><td align="center">当对象销毁时，自动调用</td></tr><tr><td align="center">函数名称是类名</td><td align="center">函数名称~类名</td></tr><tr><td align="center">构造函数可以重载</td><td align="center">析构函数没有参数，不能重载</td></tr><tr><td align="center">用于创建对象时并初始化</td><td align="center">用于销毁对象释放资源</td></tr><tr><td align="center">有返回值但是不写，返回值时新创建的对象</td><td align="center">没有返回值</td></tr></tbody></table><h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><blockquote><p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p><ul><li>通过使用另一个同类型的对象来初始化新创建的对象。</li><li>复制对象把它作为参数传递给函数。</li><li>复制对象，并从函数返回这个对象。</li></ul><p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果<strong>类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数</strong>(下文详解)。</p></blockquote><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><blockquote><p>浅拷贝：拷贝构造函数仅仅拷贝指针，而不拷贝指针指向的对象。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">char</span> *n)</span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">20</span>] = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d1</span><span class="params">(arr)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d2</span><span class="params">(d1)</span></span>; <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(arr,<span class="string">&quot;大黄&quot;</span>);   <span class="comment">// 浅拷贝更改外部内存，对象内的数据，也被更改。因为操作的是同一块内存</span></span><br><span class="line">    d<span class="number">1.</span><span class="built_in">show_name</span>();</span><br><span class="line">    d<span class="number">2.</span><span class="built_in">show_name</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>Dog</code>类没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，该函数会拷贝指针，而不拷贝指针指向的对象。所以，<code>d2</code>的<code>name</code>指针指向的地址是<code>d1</code>的<code>name</code>指针指向的地址，但是<code>d2</code>的<code>name</code>指针指向的内存块的内容是<code>d1</code>的<code>name</code>指针指向的内存块的内容。</p></blockquote><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><blockquote><p>深拷贝：拷贝构造函数开辟新空间，并将指针指向新空间，然后将原对象内的数据拷贝到新空间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">char</span> *n)</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> Dog &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name,d.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">20</span>] = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d1</span><span class="params">(arr)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d2</span><span class="params">(d1)</span></span>; <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(arr,<span class="string">&quot;大黄&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    d<span class="number">1.</span><span class="built_in">show_name</span>(); <span class="comment">// 旺财</span></span><br><span class="line">    d<span class="number">2.</span><span class="built_in">show_name</span>(); <span class="comment">// 旺财</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>Dog</code>类定义了一个拷贝构造函数，它开辟新空间，并将指针指向新空间，然后将原对象内的数据拷贝到新空间。所以，<code>d2</code>的<code>name</code>指针指向的地址和内容都不同于<code>d1</code>的<code>name</code>指针指向的地址和内容。</p></blockquote><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><blockquote><p>封装是指将类的属性和行为隐藏在类的内部，只向外提供访问接口，隐藏内部的实现细节。</p></blockquote><h2 id="类的成员访问控制"><a href="#类的成员访问控制" class="headerlink" title="类的成员访问控制"></a>类的成员访问控制</h2><blockquote><p>类成员的访问控制决定了外部代码是否可以访问该成员。</p></blockquote><ul><li>public：公有成员，可以在任何地方访问。</li><li>private：私有成员，只能在类内部访问。</li><li>protected：受保护成员，可以在类内部和派生类中访问。</li></ul><blockquote><p>C++中默认的访问控制是private，即类的成员只能在类内部访问。</p></blockquote><h2 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h2><blockquote><p>这里通过访问控制实现封装：通过public、private、protected关键字来控制类的成员的访问权限。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">            num = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setNum</span>(<span class="number">10</span>);</span><br><span class="line">    cout&lt;&lt;obj.<span class="built_in">getNum</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>num</code>是私有的，只能在类内部访问，外部代码无法直接访问。只能通过<code>setNum()</code>和<code>getNum()</code>来访问。</p></blockquote><h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><blockquote><ul><li>隐藏实现细节，提高代码的可读性和可维护性。</li><li>提高代码的安全性，防止代码被随意修改。</li><li>减少代码的耦合度，降低代码的依赖性。</li></ul></blockquote><h1 id="作用域限定符"><a href="#作用域限定符" class="headerlink" title="::作用域限定符"></a>::作用域限定符</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><blockquote><p>命名空间(namespace)是C++中一个重要的概念，它用来解决命名冲突的问题。</p></blockquote><blockquote><p>命名空间的作用：</p><ul><li>解决命名冲突：不同的命名空间可以包含同名的变量、函数、类等，因此可以有效地避免命名冲突。</li><li>组织代码：命名空间可以组织代码，使得代码更加容易理解和维护。</li></ul></blockquote><h3 id="命名空间的声明"><a href="#命名空间的声明" class="headerlink" title="命名空间的声明"></a>命名空间的声明</h3><blockquote><p>命名空间的声明语法：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名&#123;</span><br><span class="line">    <span class="comment">// 声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间的声明一般在头文件中，用来声明命名空间中的变量、函数、类等。</p></blockquote><h3 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h3><blockquote><p>命名空间的使用语法：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间名;</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> my_space</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> my_space;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 1 就近原则</span></span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; endl;    <span class="comment">// ::匿名名字空间。2   暂时理解为从全局找</span></span><br><span class="line">    cout &lt;&lt; my_space::a &lt;&lt; endl;    <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>using namespace</code>语句可以将命名空间中的变量、函数、类等引入当前的作用域，这样就可以省略命名空间名。</p></blockquote><h2 id="类内声明，类外定义"><a href="#类内声明，类外定义" class="headerlink" title="类内声明，类外定义"></a>类内声明，类外定义</h2><blockquote><p>类内声明：在类内部声明变量、函数等。</p></blockquote><blockquote><p>类外定义：在类外定义变量、函数等。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类内声明</span></span><br><span class="line">    <span class="built_in">Demo</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(string str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义</span></span><br><span class="line">Demo::<span class="built_in">Demo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo::test</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str= &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Demo d;</span><br><span class="line">    d.<span class="built_in">test</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>Demo</code>类内声明了一个构造函数和一个函数<code>test</code>，类外定义了一个构造函数和一个函数<code>test</code>。</p></blockquote><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><blockquote><p>this指针是指向当前对象的指针，在成员函数中，可以通过<code>this</code>指针访问当前对象的成员变量和成员函数,还可以用来区分同名的成员变量和局部变量。</p></blockquote><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><blockquote><p>链式调用：当成员函数的返回值是当前类型的引用时，可以通过<code>this</code>指针调用另一个成员函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Test&amp; <span class="title">add</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val += i;   <span class="comment">// val = val + i;</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// this是一个指针，取内容返回当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">add</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span><span class="built_in">get_val</span>() &lt;&lt; endl;   <span class="comment">// 103</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式调用</span></span><br><span class="line">    Test t2;</span><br><span class="line">    cout &lt;&lt; t<span class="number">2.</span><span class="built_in">add</span>(<span class="number">2</span>).<span class="built_in">add</span>(<span class="number">32</span>).<span class="built_in">add</span>(<span class="number">200</span>).<span class="built_in">get_val</span>() &lt;&lt; endl;   <span class="comment">// 234</span></span><br><span class="line">    cout &lt;&lt; t<span class="number">2.</span><span class="built_in">get_val</span>() &lt;&lt; endl;   <span class="comment">// 234</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>Test</code>类有一个<code>add</code>函数，它的返回值是<code>Test</code>类的引用，通过<code>this</code>指针可以调用另一个成员函数。</p></blockquote><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><blockquote><p>static关键字用来修饰成员变量和成员函数，用来实现静态成员。</p></blockquote><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><blockquote><p>静态成员变量：静态成员变量属于整个类，不属于任何一个对象，它在内存中只分配一次，所有对象共享同一份数据。可以脱离对象使用。需要类内声明，类外定义。在程序开始时创建，程序结束时销毁。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    static int b = 2; // 错误，静态成员变量需要类内声明。类外初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;   <span class="comment">// 类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外初始化</span></span><br><span class="line"><span class="type">int</span> Test::b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; Test::b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;Test::b &lt;&lt; endl; <span class="comment">// 1 0x403004</span></span><br><span class="line">    Test t1;</span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span>a++ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;t<span class="number">1.</span>a &lt;&lt; endl; <span class="comment">// 1 0x61fe8c</span></span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span>b++ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;t<span class="number">1.</span>b &lt;&lt; endl; <span class="comment">// 1 0x403004</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span>a++ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;t<span class="number">1.</span>a &lt;&lt; endl; <span class="comment">// 2 0x61fe8c</span></span><br><span class="line">    cout &lt;&lt; t<span class="number">1.</span>b++ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;t<span class="number">1.</span>b &lt;&lt; endl; <span class="comment">// 2 0x403004</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Test t2;</span><br><span class="line">    cout &lt;&lt; t<span class="number">2.</span>a++ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;t<span class="number">2.</span>a &lt;&lt; endl; <span class="comment">// 1 0x61fe88</span></span><br><span class="line">    cout &lt;&lt; t<span class="number">2.</span>b++ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;t<span class="number">2.</span>b &lt;&lt; endl; <span class="comment">// 3 0x403004</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Test::b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;Test::b &lt;&lt; endl;<span class="comment">// 4 0x403004</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>Test</code>类有一个静态成员变量<code>b</code>，它在内存中只分配一次，所有对象共享同一份数据。</p></blockquote><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><blockquote><p>静态成员函数：静态成员函数属于整个类，不属于任何一个对象，它可以直接通过类名调用。因此，静态成员函数没有this指针，不能访问类的非静态成员。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        func1(); </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        func0(); // 错误，静态成员函数，不能调用非静态成员</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;静态成员函数2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Test::func1();</span></span><br><span class="line">    Test t1;</span><br><span class="line"><span class="comment">//    t1.func0();</span></span><br><span class="line">    t<span class="number">1.f</span>unc1();</span><br><span class="line"><span class="comment">//    t1.func2();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>Test</code>类有一个静态成员函数<code>func1</code>，它可以直接通过类名调用。</p></blockquote><h3 id="静态成员函数调用非静态成员的方法："><a href="#静态成员函数调用非静态成员的方法：" class="headerlink" title="静态成员函数调用非静态成员的方法："></a>静态成员函数调用非静态成员的方法：</h3><blockquote><ul><li>通过参数传递对象进来。（我没有可以找别人要）</li><li>在静态成员函数中创建个对象进行调用。（既然我没有那就造一个用）</li></ul></blockquote><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><blockquote><p>静态局部变量：静态局部变量属于整个函数，不属于任何一个对象，它在内存中只分配一次，所有对象共享同一份数据。</p></blockquote><h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><h2 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h2><blockquote><p>const修饰成员函数：const修饰成员函数，表示该函数不能修改类的成员变量，只能访问类的成员变量，不能调用非const成员函数。</p></blockquote><h2 id="const修饰成员变量"><a href="#const修饰成员变量" class="headerlink" title="const修饰成员变量"></a>const修饰成员变量</h2><blockquote><p>const修饰成员变量：const修饰成员变量，表示该成员变量只能读取不能修改。<br>两种初始化方式：</p><ul><li>声明后赋值就是直接初始化。</li><li>构造参数初始化列表</li></ul></blockquote><h2 id="const修饰局部变量"><a href="#const修饰局部变量" class="headerlink" title="const修饰局部变量"></a>const修饰局部变量</h2><blockquote><p>const修饰局部变量：const修饰局部变量，表示该变量只能读取不能修改。常用于引用传递函数传参，修饰引用参数。</p></blockquote><h2 id="const修饰对象"><a href="#const修饰对象" class="headerlink" title="const修饰对象"></a>const修饰对象</h2><blockquote><p>const修饰对象：const修饰对象，表示该对象只能读取不能修改。无法调用非const成员函数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux阻塞模式</title>
      <link href="/2024/08/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/08/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h1><blockquote><p>如果多个出于就绪态的任务具有相同优先级，它们之间互相不能抢占，那应该是谁得到CPU？答案有两种，有的系统实现是根据进入就绪态的时间对相同优先级的任务进行排序，先运行第一个，等第一个运行完成主动让出CPU之后再运行第二个，依次类推。这方式并不太常见，因为相同优先级的任务往往希望能够共享CPU，也就是第二种方式：按时间片轮转运行。即多个任务轮流得到操作系统的调度，每次得到调度的任务执行时间为一个“时间片”</p></blockquote><p><img src="https://s2.loli.net/2024/08/27/aC9tHObGsmvQd2x.webp" alt=".webp"></p><blockquote><p>一共有3个用户任务Task1&#x2F;Task2&#x2F;Task3在轮流执行，t1&#x2F;t2&#x2F;t3&#x2F;t4&#x2F;t5任意两个相邻之间的时间间隔就是一个时间片，黑色箭头表示Tick中断发生，红色为操作系统内核执行调度程序。什么是Tick?在不同的资料里叫法不同，有的叫“时钟节拍”，有的叫“心跳”，“滴答”等等，它们的作用是一样的，就是在每个时间片到期的时候，触发一次tick中断，给调度器一个机会来运行本身，寻找下一个需要分配CPU的任务。</p></blockquote><h1 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h1><blockquote><p><strong>特点：最简单、最常用；      效率低</strong> —相对进程来说</p></blockquote><h2 id="阻塞原因与阻塞反应"><a href="#阻塞原因与阻塞反应" class="headerlink" title="阻塞原因与阻塞反应"></a>阻塞原因与阻塞反应</h2><blockquote><p>阻塞I&#x2F;O 模式是最普遍使用的I&#x2F;O 模式，大部分程序使用的都是阻塞模式的I&#x2F;O 。<br>缺省情况下（及系统默认状态），套接字建立后所处于的模式就是阻塞I&#x2F;O 模式。<br>学习的读写函数在调用过程中会发生阻塞相关函数如下：<br>•读操作中的read、recv、recvfrom<br>    读阻塞–&gt;需要读缓冲区中有数据可读，读阻塞解除<br>•写操作中的write、send<br>    写阻塞–&gt;阻塞情况比较少，主要发生在写入的缓冲区的大小小于要写入的数据量的情况下，写操作不进行任何拷贝工作，将发生阻塞，一旦缓冲区有足够的空间，内核将唤醒进程，将数据从用户缓冲区拷贝到相应的发送数据缓冲区。<br>注意：sendto没有写阻塞<br>1）无sendto函数的原因：<br>sendto不是阻塞函数，本身udp通信不是面向连接的，udp无发送缓冲区，即sendto没有发送缓冲区，send是有发送缓存区的，即sendto不是阻塞函数。<br>2）UDP不用等待确认，没有实际的发送缓冲区，所以UDP协议中不存在缓冲区满的情况，在UDP套接字上进行写操作永远不会阻塞。<br>•其他操作：accept、connect</p></blockquote><h1 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h1><blockquote><p><strong>特点：可以处理多路IO；需要轮询，浪费CPU资源</strong><br>非阻塞并不是说将一个函数设置为非阻塞即可，而是想在非阻塞模式的情况下继续实现当前的需求</p></blockquote><h2 id="那什么是轮询呢？"><a href="#那什么是轮询呢？" class="headerlink" title="那什么是轮询呢？"></a>那什么是轮询呢？</h2><blockquote><p>当一个应用程序使用了非阻塞模式的套接字，它需要使用一个循环来不停地测试是否一个文件描述符有数据可读（称做polling）。—轮询</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/20/hello-world/"/>
      <url>/2024/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Socket套接字编程</title>
      <link href="/2024/08/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/08/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket套接字编程基础"><a href="#Socket套接字编程基础" class="headerlink" title="Socket套接字编程基础"></a>Socket套接字编程基础</h1><h2 id="Socket简介"><a href="#Socket简介" class="headerlink" title="Socket简介"></a>Socket简介</h2><blockquote><p>Socket是一种通信机制，应用程序通常通过它与另一个应用程序进行通信。Socket是一组接口，应用程序可以通过它向网络发出请求或者接收数据。Socket是建立在Internet协议(IP)之上的，它是网络通信的基础。Socket允许应用程序在不了解网络内部的细节的情况下，实现网络通信。<br>Socket由两部分组成：一端称为服务器端，另一端称为客户端。服务器端运行一个程序，等待客户端的连接请求。一旦客户端连接到服务器端，服务器端与客户端之间就建立了一个Socket连接。客户端和服务器端通过这个Socket连接，就可以进行网络通信。</p></blockquote><h3 id="Socket通信模型有两种："><a href="#Socket通信模型有两种：" class="headerlink" title="Socket通信模型有两种："></a>Socket通信模型有两种：</h3><ul><li>面向连接(TCP)：通信双方必须先建立连接，才能进行通信。</li><li>无连接(UDP)：通信双方不需要先建立连接，直接就可以进行通信。</li></ul><h2 id="socket类型"><a href="#socket类型" class="headerlink" title="socket类型"></a>socket类型</h2><ul><li><strong>SOCK_STREAM</strong>：流式套接字 TCP<ul><li>流式Socket，提供可靠的、双向的、字节流服务。</li></ul></li><li><strong>SOCK_DGRAM</strong>：数据报套接字 UDP<ul><li>数据报式Socket，提供不可靠的、单向的、消息流服务。</li></ul></li><li>SOCK_RAW：原始Socket，提供原始的网络协议访问。</li></ul><h2 id="端口号-port"><a href="#端口号-port" class="headerlink" title="端口号 port"></a>端口号 port</h2><ul><li>使用端口号来标识网络应用程序。</li><li>TCP端口和UDP端口相互独立</li><li>端口用两个字节表示  2byte &#x3D; 16bit</li><li>端口号范围：0~65535<ul><li>众所周知端口：1~1023（1~255之间为众所周知端口，256~1023端口通常由UNIX系统占用）</li><li>已登记端口：1024~49151    （<strong>选1000以上10000以下进行注册</strong>，以避免与已知端口冲突）</li><li>动态或私有端口：49152~65535</li></ul></li></ul><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><ul><li>大端字节序: 高位字节排放在内存的低地址中，低位字节排放在内存的高地址中。</li><li>小端字节序: 低位字节排放在内存的低地址中，高位字节排放在内存的高地址中。</li><li>网络字节序: 大端字节序。’</li></ul><h3 id="主机字节序与网络字节序间的转换"><a href="#主机字节序与网络字节序间的转换" class="headerlink" title="主机字节序与网络字节序间的转换"></a>主机字节序与网络字节序间的转换</h3><blockquote><h4 id="主机字节序到网络字节序的转换："><a href="#主机字节序到网络字节序的转换：" class="headerlink" title="主机字节序到网络字节序的转换："></a>主机字节序到网络字节序的转换：</h4></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u_long <span class="title function_">htonl</span><span class="params">(u_long hostlong)</span>;        <span class="comment">// 32位主机字节序转32位网络字节序</span></span><br><span class="line">u_short <span class="title function_">htons</span><span class="params">(u_short hostshort)</span>;     <span class="comment">// 16位主机字节序转16位网络字节序</span></span><br></pre></td></tr></table></figure><p>细看<strong>htons</strong>函数，它是将 16 位的主机字节序转化为 16 位的网络字节序，很明显<strong>端口号转换</strong>就是通过这个函数来实现的。</p><blockquote><h4 id="网络字节序到主机字节序的转换："><a href="#网络字节序到主机字节序的转换：" class="headerlink" title="网络字节序到主机字节序的转换："></a>网络字节序到主机字节序的转换：</h4></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u_long <span class="title function_">ntohl</span><span class="params">(u_long netlong)</span>;</span><br><span class="line">u_short <span class="title function_">ntohs</span><span class="params">(u_short netshort)</span>;</span><br></pre></td></tr></table></figure><h3 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;  <span class="comment">//从人看的到机器识别的32位无符</span></span><br><span class="line">号整数</span><br><span class="line"><span class="type">char</span> * <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;  <span class="comment">//从机器到人</span></span><br></pre></td></tr></table></figure><h1 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h1><blockquote><h2 id="TCP连接过程"><a href="#TCP连接过程" class="headerlink" title="TCP连接过程"></a>TCP连接过程</h2></blockquote><p><img src="https://s2.loli.net/2024/08/26/XHyEbt7huP413aJ.png" alt="TCP.png"></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li>服务器调用socket函数创建一个套接字，指定为SOCK_STREAM类型，TCP协议。</li><li>服务器调用bind函数绑定一个本地地址和端口，用于监听客户端的连接请求。</li><li>服务器调用listen函数，开始监听客户端的连接请求。</li><li>服务器调用accept函数等待客户端的连接请求。</li><li>服务器接收客户端的连接请求后，调用accept函数返回一个新的套接字，用于与客户端通信。</li><li>通信结束后，服务器调用close函数关闭套接字。</li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>客户端调用socket函数创建一个套接字，指定为SOCK_STREAM类型，TCP协议。</li><li>客户端调用connect函数，根据IP地址和端口号向指定服务器发送连接请求。</li><li>成功连接后，客户端和服务器之间就可以开始通信。</li><li>通信结束后，客户端调用close函数关闭套接字。</li></ol><blockquote><h2 id="TCP编程函数"><a href="#TCP编程函数" class="headerlink" title="TCP编程函数"></a>TCP编程函数</h2></blockquote><h3 id="1-socket-：创建套接字"><a href="#1-socket-：创建套接字" class="headerlink" title="1. socket()：创建套接字"></a>1. socket()：创建套接字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">功能：创建套接字</span><br><span class="line">参数：</span><br><span class="line">   domain：协议族</span><br><span class="line">     AF_UNIX, AF_LOCAL  本地通信</span><br><span class="line">     AF_INET            ipv4</span><br><span class="line">     AF_INET6            ipv6</span><br><span class="line">  type：套接字类型</span><br><span class="line">     SOCK_STREAM:流式套接字----TCP</span><br><span class="line">     SOCK_DGRAM：数据报套接字---UDP</span><br><span class="line">  protocol：协议 - 填<span class="number">0</span> 自动匹配底层 ，根据type系统默认自动帮助匹配对应协议</span><br><span class="line"> 返回值：</span><br><span class="line">    成功 文件描述符</span><br><span class="line">    失败 <span class="number">-1</span>，更新errno</span><br></pre></td></tr></table></figure><h3 id="2-bind-：绑定本地地址和端口"><a href="#2-bind-：绑定本地地址和端口" class="headerlink" title="2. bind()：绑定本地地址和端口"></a>2. bind()：绑定本地地址和端口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">         <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：绑定   ipv4  ip和端口 </span><br><span class="line">参数</span><br><span class="line">   sockfd：文件描述符</span><br><span class="line">   addr：通用结构体，根据socket第一个参数选择的通信方式最终确定这需要真正填充传递的结构体是那个类型。强转后传参数。</span><br><span class="line"></span><br><span class="line">   addrlen:填充的结构体的大小   </span><br><span class="line">返回值：成功<span class="number">0</span> 失败<span class="number">-1</span>、更新errno</span><br><span class="line"></span><br><span class="line">通用结构体：相当于预留一个空间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipv4的结构体 </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">     <span class="type">sa_family_t</span>    sin_family;  <span class="comment">//协议族AF_INET</span></span><br><span class="line">     <span class="type">in_port_t</span>      sin_port;  <span class="comment">//端口</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   </span><br><span class="line"> &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">     <span class="type">uint32_t</span>       s_addr;   <span class="comment">//IP地址  </span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">ipv6通信结构体：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>     sin6_family;   </span><br><span class="line">    <span class="type">in_port_t</span>       sin6_port;     </span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     </span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   s6_addr[<span class="number">16</span>];   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果绑定使用通用地址可使用 INADDR_ANY宏定义，含义是自动绑定所有本机网卡的地址，</span></span><br></pre></td></tr></table></figure><p><em>因为bind适用于IPV4、ipv6等网络通信，又由于不同的网络通信需要填充的结构体不一样，但是编译器要求第二参数数据类型固定，为避免编译器警告，所以我们使用了一个通用结构体来兼容所有的结构体，填充自己协议对应的结构体，然后强转传参即可。</em></p><h3 id="3-listen-：监听连接请求"><a href="#3-listen-：监听连接请求" class="headerlink" title="3. listen()：监听连接请求"></a>3. listen()：监听连接请求</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">功能:监听，将主动套接字变为被动套接字</span><br><span class="line">参数：</span><br><span class="line"> sockfd：套接字</span><br><span class="line"> backlog：同时响应客户端请求链接的最大个数，不能写<span class="number">0.</span></span><br><span class="line">  不同平台可同时链接的数不同，一般写<span class="number">6</span><span class="number">-8</span>个</span><br><span class="line">返回值：成功 <span class="number">0</span>   失败<span class="number">-1</span>,更新errno  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-accept-：接收连接请求"><a href="#4-accept-：接收连接请求" class="headerlink" title="4. accept()：接收连接请求"></a>4. accept()：接收连接请求</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">accept(sockfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">阻塞函数，阻塞等待客户端的连接请求，如果有客户端连接，</span><br><span class="line">则accept()函数返回，返回一个用于通信的套接字文件;</span><br><span class="line">参数：</span><br><span class="line">   Sockfd ：套接字</span><br><span class="line">   addr： 链接客户端的ip和端口号</span><br><span class="line">      如果不需要关心具体是哪一个客户端，那么可以填<span class="literal">NULL</span>;</span><br><span class="line">   addrlen：结构体的大小</span><br><span class="line">     如果不需要关心具体是哪一个客户端，那么可以填<span class="literal">NULL</span>;</span><br><span class="line">  返回值： </span><br><span class="line">     成功：文件描述符; <span class="comment">//用于通信</span></span><br><span class="line">失败：<span class="number">-1</span>，更新errno</span><br></pre></td></tr></table></figure><h3 id="5-connect-：连接服务器"><a href="#5-connect-：连接服务器" class="headerlink" title="5. connect()：连接服务器"></a>5. connect()：连接服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：用于连接服务器；</span><br><span class="line">参数：</span><br><span class="line">     sockfd：socket函数的返回值</span><br><span class="line">     addr：填充的结构体是服务器端的；</span><br><span class="line">     addrlen：结构体的大小</span><br><span class="line">返回值 </span><br><span class="line">      <span class="number">-1</span> 失败，更新errno</span><br><span class="line">      正确 <span class="number">0</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-send-：发送数据"><a href="#6-send-：发送数据" class="headerlink" title="6. send()：发送数据"></a>6. send()：发送数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line">功能：发送数据</span><br><span class="line">参数：</span><br><span class="line">    sockfd:socket函数的返回值</span><br><span class="line">    buf：发送内容存放的地址</span><br><span class="line">    len：发送内存的长度</span><br><span class="line">    flags：如果填<span class="number">0</span>，相当于write();</span><br><span class="line">返回值：</span><br><span class="line">    成功发送的字节数</span><br><span class="line">    失败 <span class="number">-1</span>，更新errno</span><br></pre></td></tr></table></figure><h3 id="7-recv-：接收数据"><a href="#7-recv-：接收数据" class="headerlink" title="7. recv()：接收数据"></a>7. recv()：接收数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line">功能: 接收数据 </span><br><span class="line">参数： </span><br><span class="line">    sockfd： acceptfd ;</span><br><span class="line">    buf  存放位置</span><br><span class="line">    len  大小</span><br><span class="line">    flags  一般填<span class="number">0</span>，相当于read()函数</span><br><span class="line">    MSG_DONTWAIT  非阻塞</span><br><span class="line">返回值： </span><br><span class="line">   &lt; <span class="number">0</span>  失败出错  更新errno</span><br><span class="line">   ==<span class="number">0</span>  表示客户端退出</span><br><span class="line">   &gt;<span class="number">0</span>   成功接收的字节个数</span><br></pre></td></tr></table></figure><h3 id="8-close-：关闭套接字"><a href="#8-close-：关闭套接字" class="headerlink" title="8. close()：关闭套接字"></a>8. close()：关闭套接字</h3><blockquote><h2 id="TCP编程实例（模拟一个FTP服务）"><a href="#TCP编程实例（模拟一个FTP服务）" class="headerlink" title="TCP编程实例（模拟一个FTP服务）"></a>TCP编程实例（模拟一个FTP服务）</h2></blockquote><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;加 端口号 文件名\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定ip,por</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, len) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind ok\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 监听连接，主动变被动</span></span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待连接，如果有连接就创建套接字并返回文件描述符</span></span><br><span class="line">    <span class="type">int</span> accfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;caddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (accfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;accept ok\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IP:%s,Port:%d\n&quot;</span>, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;accfd: %d\n&quot;</span>, accfd);</span><br><span class="line">    <span class="comment">// 开文件接收</span></span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">9999</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ret = recv(accfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            write(fd, buf, ret);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv err&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client exit\n&quot;</span>);</span><br><span class="line">            close(accfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;加ip 端口号 文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开要传输的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">3</span>],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确定服务器进行连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family=AF_INET;</span><br><span class="line">    saddr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    saddr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">socklen_t</span> slen = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;saddr,slen)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect ok\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">9999</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送</span></span><br><span class="line">        <span class="type">int</span> rnum=read(fd,buf,<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(!rnum)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        send(sockfd,buf,rnum,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h1><blockquote><h2 id="UDP连接过程"><a href="#UDP连接过程" class="headerlink" title="UDP连接过程"></a>UDP连接过程</h2></blockquote><p><img src="https://s2.loli.net/2024/08/27/kXGYvLSxm2AIzDe.png" alt="UDP.png"></p><h3 id="服务端和客户端"><a href="#服务端和客户端" class="headerlink" title="服务端和客户端"></a>服务端和客户端</h3><ol><li>服务端调用socket函数创建一个套接字，指定为SOCK_DGRAM类型，UDP协议。</li><li>服务端调用bind函数绑定一个本地地址和端口，用于监听客户端的连接请求。</li><li>服务端等待客户端的连接请求。</li><li>客户端调用connect函数，根据IP地址和端口号向指定服务器发送连接请求。</li><li>成功连接后，客户端和服务器之间就可以开始通信。</li><li>通信结束后，客户端调用close函数关闭套接字。</li></ol><blockquote><h2 id="UDP编程函数"><a href="#UDP编程函数" class="headerlink" title="UDP编程函数"></a>UDP编程函数</h2></blockquote><h3 id="1-recvfrom-：接收数据"><a href="#1-recvfrom-：接收数据" class="headerlink" title="1. recvfrom()：接收数据"></a>1. recvfrom()：接收数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">功能：接收数据</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">sockfd：套接字描述符</span><br><span class="line">buf:接收缓存区的首地址</span><br><span class="line">len：接收缓存区的大小</span><br><span class="line">flags：<span class="number">0</span></span><br><span class="line">src_addr:发送端的网络信息结构体的指针</span><br><span class="line">addrlen：发送端的网络信息结构体的大小的指针</span><br><span class="line">  </span><br><span class="line">返回值：</span><br><span class="line">成功接收的字节个数</span><br><span class="line">失败：<span class="number">-1</span></span><br><span class="line"><span class="number">0</span>:客户端退出</span><br></pre></td></tr></table></figure><h3 id="2-sendto-：发送数据"><a href="#2-sendto-：发送数据" class="headerlink" title="2. sendto()：发送数据"></a>2. sendto()：发送数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：发送数据</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">sockfd：套接字描述符</span><br><span class="line">buf:发送缓存区的首地址</span><br><span class="line">len：发送缓存区的大小</span><br><span class="line">flags：<span class="number">0</span></span><br><span class="line">src_addr:接收端的网络信息结构体的指针</span><br><span class="line">addrlen：接收端的网络信息结构体的大小</span><br><span class="line"></span><br><span class="line">返回值： </span><br><span class="line">成功发送的字节个数</span><br><span class="line">失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><blockquote><h2 id="UDP编程示例"><a href="#UDP编程示例" class="headerlink" title="UDP编程示例"></a>UDP编程示例</h2></blockquote><h3 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family=AF_INET;</span><br><span class="line">    saddr.sin_port=htons(<span class="number">8888</span>);</span><br><span class="line">    saddr.sin_addr.s_addr=inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    <span class="type">socklen_t</span> slen = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line">    bind(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;saddr,slen);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        recvfrom(sockfd,buf,<span class="number">100</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;saddr,&amp;slen);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family=AF_INET;</span><br><span class="line">    saddr.sin_port=htons(<span class="number">8888</span>);</span><br><span class="line">    saddr.sin_addr.s_addr=inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    <span class="type">socklen_t</span> slen = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sendto(sockfd,buf,<span class="number">100</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;saddr,&amp;slen);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></blockquote><p>从代码看来UDP的服务器和客户端其实相差不大，因为UDP的通信不需要建立连接，只需要知道对方的IP地址和端口号就可以直接通信。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="/2024/08/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/08/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="网络发展史"><a href="#网络发展史" class="headerlink" title="网络发展史"></a>网络发展史</h1><blockquote><p>视频了解<br>【你在网上勇闯天涯时用的网络，是如何发展至今的呢？【计算机网络发展史】】 <a href="https://www.bilibili.com/video/BV1WA4m1w7KP/?share_source=copy_web&vd_source=c85863ec962cf973fb783a3554f4ef60">https://www.bilibili.com/video/BV1WA4m1w7KP/?share_source=copy_web&amp;vd_source=c85863ec962cf973fb783a3554f4ef60</a></p></blockquote><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><ol><li>IP地址是Internet上每台计算机或网络设备的唯一标识符。</li><li>Internet中的主机要与别的机器通信必须具有一个IP地址</li><li>IP地址为32位（IPv4）或者128位（IPv6）</li><li>表示形式：常用点分十进制形式，如202.38.64.10，最后都会转换为一个32位的无符号整数。</li></ol><h2 id="IP地址划分"><a href="#IP地址划分" class="headerlink" title="IP地址划分"></a>IP地址划分</h2><blockquote><p>A类：1.0.0.1~126.255.255.254<br>B类：128.0.0.1~191.255.255.254<br>C类：192.0.0.1~223.255.255.254<br>D类（组播地址）：224.0.0.1~239.255.255.254j<br>E类：保留待用   11110</p></blockquote><h2 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h2><blockquote><p>127.0.0.1~127.255.255.255为环回地址，用于本机测试。<br>0.0.0.0：在服务器中，0.0.0.0指的是本机上的所有IPV4地址，如果一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个ip地址都能够访问该服务。</p></blockquote><h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><blockquote><p><strong>端口号是TCP&#x2F;IP协议中用于标识网络程序的逻辑连接点的号码。</strong><br>端口号用两个字节表示，取值范围是0~65535。<br>常用端口号：<br>20&#x2F;21：FTP数据连接端口<br>22：SSH远程登录端口<br>23：Telnet远程登录端口<br>25：SMTP邮件传输端口<br>53：DNS域名解析服务端口<br>80：HTTP超文本传输协议端口<br>110：POP3邮件接收服务端口<br>143：IMAP邮件接收服务端口<br>443：HTTPS安全超文本传输协议端口</p></blockquote><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><blockquote><p>网络地址转换（Network Address Translation，NAT）是一种用于在网络中转换IP地址的技术。它通常用于将多个私有IP地址映射到一个或多个公共IP地址上，从而允许内网设备访问外部网络（如互联网）。NAT的主要目的是节省IP地址空间和增强网络安全，因为它隐藏了内网设备的真实IP地址。</p></blockquote><h3 id="NAT的主要类型："><a href="#NAT的主要类型：" class="headerlink" title="NAT的主要类型："></a>NAT的主要类型：</h3><blockquote><ol><li>静态NAT：一对一的映射，每个私有IP地址对应一个固定的公共IP地址。</li><li>动态NAT：使用一个公共IP地址池，私有IP地址动态映射到可用的公共IP地址。</li><li>PAT（端口地址转换）：又称为“端口映射”或“伪装”，多个私有IP地址通过不同的端口号共享一个公共IP地址。</li></ol></blockquote><h2 id="静态NAT"><a href="#静态NAT" class="headerlink" title="静态NAT"></a>静态NAT</h2><h3 id="静态NAT的过程如下："><a href="#静态NAT的过程如下：" class="headerlink" title="静态NAT的过程如下："></a>静态NAT的过程如下：</h3><blockquote><ol><li>配置映射规则：网络管理员在NAT设备（如路由器）上手动配置静态NAT映射规则，将内网设备的私有IP地址映射到一个固定的公共IP地址上。</li><li>数据包到达NAT设备：当内网设备向外部发送数据包时，该数据包首先到达NAT设备。</li><li>IP地址转换：NAT设备根据预先配置的映射规则，将数据包的源IP地址替换为对应的公共IP地址。</li><li>数据包发送到目标设备：NAT设备将转换后的数据包发送到目标设备（外网）。</li><li>返回数据包的处理：外部设备的响应数据包返回时，NAT设备将目标IP地址（即之前的公共IP地址）重新转换为私有IP地址，然后将数据包转发到内网设备。</li></ol></blockquote><h2 id="动态NAT"><a href="#动态NAT" class="headerlink" title="动态NAT"></a>动态NAT</h2><h3 id="动态NAT的过程如下："><a href="#动态NAT的过程如下：" class="headerlink" title="动态NAT的过程如下："></a>动态NAT的过程如下：</h3><blockquote><ol><li>配置地址池：网络管理员在NAT设备上配置一个公共IP地址池，用于动态分配给内网设备。</li><li>数据包到达NAT设备：当内网设备向外部发送数据包时，该数据包到达NAT设备。</li><li>分配公共IP地址：NAT设备从地址池中动态选择一个未使用的公共IP地址，并将其分配给该私有IP地址，建立临时的映射关系。</li><li>IP地址转换：NAT设备将数据包的源IP地址替换为分配的公共IP地址。</li><li>数据包发送到目标设备：转换后的数据包被发送到外部设备。</li><li>返回数据包的处理：外部设备的响应数据包返回时，NAT设备根据临时映射关系将目标IP地址（即之前的公共IP地址）重新转换为私有IP地址，并将数据包转发到内网设备。</li><li>释放IP地址：一旦通信完成，公共IP地址被释放，供下一个请求使用。</li></ol></blockquote><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><blockquote><p>DHCP（动态主机配置协议，Dynamic Host Configuration Protocol）是一种网络协议，用于自动为网络中的设备分配IP地址和其他网络配置参数，如子网掩码、网关和DNS服务器。DHCP简化了网络管理，使设备能够在不需要手动配置的情况下连接到网络。</p></blockquote><h3 id="DHCP的基本流程："><a href="#DHCP的基本流程：" class="headerlink" title="DHCP的基本流程："></a>DHCP的基本流程：</h3><blockquote><ol><li>请求：设备（称为客户端）连接到网络时，广播请求一个IP地址。</li><li>提供：DHCP服务器收到请求后，从其地址池中选择一个可用的IP地址，并将其提供给客户端。</li><li>确认：客户端接受服务器提供的IP地址，并向服务器发送确认消息。</li><li>使用：客户端使用分配的IP地址进行通信。IP地址通常是临时分配的，称为“租期”。</li></ol></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>DHCP自动化了IP地址分配，减少了配置错误，尤其适用于大型网络。</p><h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><blockquote><p>TCP（Transmission Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）是两种常用的网络传输协议，它们用于在计算机网络中发送数据，但工作方式和适用场景不同。</p></blockquote><h2 id="TCP（传输控制协议）特点"><a href="#TCP（传输控制协议）特点" class="headerlink" title="TCP（传输控制协议）特点"></a>TCP（传输控制协议）特点</h2><blockquote><ol><li>连接导向：TCP 是面向连接的协议，这意味着在传输数据之前，通信双方必须先建立连接（通过三次握手）。</li><li>可靠传输：TCP 提供可靠的数据传输，确保数据包按序到达目标，并且没有丢失或重复。它通过确认机制和重传机制来实现这一点。</li><li>流量控制和拥塞控制：TCP 支持流量控制和拥塞控制，能够根据网络状况动态调整传输速度，防止网络过载。</li><li>适用场景：适用于对数据传输可靠性要求高的应用，如网页浏览、文件传输和电子邮件等。</li></ol></blockquote><h2 id="UDP（用户数据报协议）"><a href="#UDP（用户数据报协议）" class="headerlink" title="UDP（用户数据报协议）"></a>UDP（用户数据报协议）</h2><blockquote><ol><li>无连接：UDP 是无连接的协议，数据在传输前不需要建立连接，数据包直接发送到目标地址。</li><li>不保证可靠性：UDP 不提供可靠的数据传输，不保证数据包按序到达，也不保证数据包不会丢失。应用程序需要自己处理这些问题。</li><li>低延迟和更高的效率：由于没有连接建立和确认机制，UDP 传输延迟低，效率高，适合对速度要求高而对可靠性要求低的应用。</li><li>适用场景：适用于实时性要求高的应用，如视频会议、在线游戏和直播等。</li></ol></blockquote><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><strong>TCP 强调数据传输的可靠性和完整性，而 UDP 则侧重传输效率和实时性。</strong></p><h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><blockquote><p>网络模型是指计算机网络的组织结构，是指网络中各个节点的功能和连接关系。</p></blockquote><h2 id="TCP-IP模型-（五层网络模型）"><a href="#TCP-IP模型-（五层网络模型）" class="headerlink" title="TCP&#x2F;IP模型 （五层网络模型）"></a>TCP&#x2F;IP模型 （五层网络模型）</h2><blockquote><p>TCP&#x2F;IP模型是互联网的基础协议，是互联网的通信模型。它将网络分为五层(也有四层的说法)。<br><img src="https://s2.loli.net/2024/08/27/C1aZnRxI9KJzr5P.png" alt="TCP.png"></p></blockquote><blockquote><ul><li>应用层：应用协议和应用程序的集合。</li><li><strong>传输层：端到端</strong>，写入源端口和目的端口决定数据交给机器的哪个任务（进程）去处理，通过端口寻址</li><li><strong>网络层：提供设备对设备的传输</strong>，可以理解为通过IP寻址机器。</li><li>网络接口和物理层：屏蔽硬件差异（驱动），向上层提供统一的操作接口。</li></ul></blockquote><h2 id="OSI模型-（七层网络模型）"><a href="#OSI模型-（七层网络模型）" class="headerlink" title="OSI模型 （七层网络模型）"></a>OSI模型 （七层网络模型）</h2><blockquote><ul><li>OSI模型是一个理想化的模型，尚未有完整的实现</li><li>OSI模型共有七层</li><li>OSI现阶段只用作教学和理论研究<br><img src="https://s2.loli.net/2024/08/27/SxGiEKcAvBRaJYz.png" alt="OSI.png"></li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信之消息队列</title>
      <link href="/2024/08/10/IO%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2024/08/10/IO%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><blockquote><p>消息队列是一种进程间通信机制，它允许一个进程向另一个进程发送消息，而无需知道对方的存在。消息队列是由消息的链表组成，每个消息都有特定的格式，并包含发送进程的标识符、接收进程的标识符和消息内容。消息队列可以实现不同进程之间的通信和同步。</p></blockquote><h1 id="消息队列的特点"><a href="#消息队列的特点" class="headerlink" title="消息队列的特点"></a>消息队列的特点</h1><ol><li>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。</li><li>消息队列可以按照类型来发送&#x2F;接收消息</li><li>在linux下消息队列的大小有限制。<ul><li>消息队列个数最多为16个；</li><li>每个消息队列总容量最多为16384字节；</li><li>每个消息内容最多为8192字节。</li></ul></li></ol><h1 id="消息队列的使用"><a href="#消息队列的使用" class="headerlink" title="消息队列的使用"></a>消息队列的使用</h1><blockquote><h2 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a>创建消息队列</h2></blockquote><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure></code></pre><ul><li><code>key</code>：消息队列的键值，用于标识消息队列。</li><li><code>msgflg</code>：消息队列的访问模式，可以设置为IPC_CREAT或0。</li></ul><blockquote><h2 id="向消息队列中添加消息"><a href="#向消息队列中添加消息" class="headerlink" title="向消息队列中添加消息"></a>向消息队列中添加消息</h2></blockquote><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure></code></pre><p>参数说明：</p><ul><li><code>msqid</code>：消息队列的标识符。</li><li><code>msgp</code>：消息的起始地址,就是指向消息的指针,消息的格式为struct msgbuf。</li><li><code>msgsz</code>：消息的长度。</li><li><code>msgflg</code>：消息发送的标志<ul><li>IPC_NOWAIT：消息没有发送完成也会立即返回。</li><li>0：知道发送完成才返回。（阻塞）<br>返回值：</li></ul></li><li>成功：返回0。</li><li>失败：返回-1，并设置<code>errno</code>错误码。</li></ul><blockquote><h2 id="从消息队列中读取消息"><a href="#从消息队列中读取消息" class="headerlink" title="从消息队列中读取消息"></a>从消息队列中读取消息</h2></blockquote><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure></code></pre><p>参数说明：</p><ul><li><code>msqid</code>：消息队列的标识符。</li><li><code>msgp</code>：消息的起始地址,就是指向消息的指针,消息的格式为struct msgbuf。</li><li><code>msgsz</code>：消息的长度。</li><li><code>msgtyp</code>：消息类型。</li><li><code>flag</code>：消息读取的标志<ul><li>IPC_NOWAIT：无消息立即返回ENOMSG。</li><li>0：若无消息则阻塞。<br>返回值：</li></ul></li><li>成功：返回接收到的消息长度。</li><li>失败：返回-1，并设置<code>errno</code>错误码。</li></ul><blockquote><h2 id="控制消息队列"><a href="#控制消息队列" class="headerlink" title="控制消息队列"></a>控制消息队列</h2></blockquote><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure></code></pre><p>参数说明：</p><ul><li><code>msqid</code>：消息队列的标识符。</li><li><code>cmd</code>：控制命令。<ul><li>IPC_STAT：获取消息队列的状态信息。</li><li>IPC_SET：设置消息队列的状态信息。</li><li><strong>IPC_RMID：删除消息队列。</strong>(主要用这个)</li></ul></li><li><code>buf</code>：消息队列的缓冲区，用于存储消息队列的状态信息。</li></ul><p>返回值：</p><ul><li>成功：返回0。</li><li>失败：返回-1，并设置<code>errno</code>错误码。</li></ul><blockquote><h1 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h1></blockquote><ul><li><p><code>ipcs -q </code>: 查看系统中所有的消息队列。</p></li><li><p><code>ipcrm -q [msgid] </code>: 删除消息队列。</p></li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_KEY 1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TYPE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[MSG_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> msqid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    msqid = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (msqid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向消息队列中添加消息</span></span><br><span class="line">    <span class="built_in">strcpy</span>(msg.mtext, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    msg.mtype = MSG_TYPE;</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msqid, &amp;msg, MSG_SIZE, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭消息队列</span></span><br><span class="line">    <span class="keyword">if</span> (msgctl(msqid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_KEY 1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TYPE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[MSG_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> msqid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开消息队列</span></span><br><span class="line">    msqid = msgget(MSG_KEY, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (msqid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从消息队列中读取消息</span></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid, &amp;msg, MSG_SIZE, MSG_TYPE, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭消息队列</span></span><br><span class="line">    <span class="keyword">if</span> (msgctl(msqid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程间通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信之共享内存与信号灯集</title>
      <link href="/2024/08/06/IO%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E4%BF%A1%E5%8F%B7%E7%81%AF%E9%9B%86/"/>
      <url>/2024/08/06/IO%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E4%BF%A1%E5%8F%B7%E7%81%AF%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><blockquote><p>共享内存是指两个或多个进程可以访问同一块内存空间，共享内存可以实现进程间通信。也就是操作系统在物理内存中申请一块空间，应用程序可以映射到这块空间，进行直接读写操作。</p></blockquote><h2 id="共享内存的特点"><a href="#共享内存的特点" class="headerlink" title="共享内存的特点"></a>共享内存的特点</h2><ol><li>共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间</li><li>进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高的效率。</li><li>由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁和信号量等</li></ol><h2 id="共享内存的实现"><a href="#共享内存的实现" class="headerlink" title="共享内存的实现"></a>共享内存的实现</h2><blockquote><p>共享内存的实现主要有以下几步：</p><ul><li>创建唯一key值，ftok函数可以生成一个唯一的key值。</li><li>创建或打开共享内存，shmget函数可以创建或打开一个共享内存。</li><li>映射到进程地址空间，shmat函数可以将共享内存映射到进程地址空间。</li><li>读写共享内存，进程可以直接读写共享内存。</li><li>解除映射，shmdt函数可以解除共享内存的映射。</li></ul></blockquote><h2 id="共享内存的应用"><a href="#共享内存的应用" class="headerlink" title="共享内存的应用"></a>共享内存的应用</h2><h3 id="创建key值"><a href="#创建key值" class="headerlink" title="创建key值"></a>创建key值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span><br></pre></td></tr></table></figure><ul><li>pathname: 共享内存的路径名，通常是文件名。</li><li>proj_id: 项目ID，用于区分不同项目的共享内存，取整数的低8位数值。</li><li>返回值：成功返回key值，失败返回-1。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    key = ftok(<span class="string">&quot;myfile&quot;</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 生成key值</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key = %d\n&quot;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>key值是根据pathname的inode号和proj_id的低8位数值生成的，如果两个进程使用同样的pathname和proj_id，则它们的key值也相同。如：<br><img src="https://s2.loli.net/2024/08/06/vVDFna3bHxNWTuk.png" alt="key.png"></li><li>pathname需要是存在的文件名，否则ftok函数会返回-1。</li></ul><h3 id="创建或打开共享内存"><a href="#创建或打开共享内存" class="headerlink" title="创建或打开共享内存"></a>创建或打开共享内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span><br></pre></td></tr></table></figure><ul><li>key: 共享内存的key值，由ftok函数生成。</li><li>size: 共享内存的大小，以字节为单位。</li><li>shmflg: 共享内存的访问权限，IPC_CREAT（创建）|IPC_EXCL（检错）|0777</li><li>返回值：成功返回共享内存的ID，失败返回-1。</li></ul><p>查看创建的共享内存命令：<code>ipcs -m</code></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;./app&quot;</span>,<span class="string">&#x27;a&#x27;</span>);         <span class="comment">// 生成key值</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key,<span class="number">64</span>,IPC_CREAT|IPC_EXCL|<span class="number">0666</span>);    <span class="comment">// 创建共享内存</span></span><br><span class="line">    <span class="keyword">if</span>(shmid&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EEXIST)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">            shmid = shmget(key,<span class="number">64</span>,<span class="number">0666</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;shimget err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="映射共享内存到进程地址空间"><a href="#映射共享内存到进程地址空间" class="headerlink" title="映射共享内存到进程地址空间"></a>映射共享内存到进程地址空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span></span><br></pre></td></tr></table></figure><ul><li>shmid: 共享内存的ID，由shmget函数生成。</li><li>shmaddr: 映射到进程地址空间的起始地址，通常设置为NULL。</li><li>shmflg: 映射的访问权限<ul><li>SHM_RDONLY（只读）</li><li>SHM_RND（随机访问）</li><li>SHM_REMAP（可重映射）</li><li>SHM_EXEC（可执行）</li><li>SHM_LOCK（锁定）</li><li>SHM_HUGETLB（大页映射）</li><li>0（可读可写）</li></ul></li><li>返回值：成功返回映射到进程地址空间的地址，失败返回(void*)-1。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;./app&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,key);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key,<span class="number">64</span>,IPC_CREAT|IPC_EXCL|<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EEXIST)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">            shmid = shmget(key,<span class="number">64</span>,<span class="number">0666</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;shimget err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="type">char</span> * p = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == (<span class="type">void</span>*)<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：读写共享内存可以直接通过指针进行，不需要进行数据拷贝。</p></blockquote><h3 id="解除映射"><a href="#解除映射" class="headerlink" title="解除映射"></a>解除映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span><br></pre></td></tr></table></figure><ul><li>shmaddr: 映射到进程地址空间的起始地址。</li><li>返回值：成功返回0，失败返回-1。</li></ul><p>示例：<code>shmadt(p)</code></p><h3 id="删除共享内存"><a href="#删除共享内存" class="headerlink" title="删除共享内存"></a>删除共享内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span><br></pre></td></tr></table></figure><ul><li>shmid: 共享内存的ID，由shmget函数生成。</li><li>cmd: 操作命令<ul><li>IPC_RMID（删除）</li><li>IPC_SET（设置）</li><li>IPC_STAT（查看）</li></ul></li><li>buf: 共享内存的属性结构体，用于设置共享内存的属性，直接设置为NULL。</li><li>返回值：成功返回0，失败返回-1。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;./app&quot;</span>,<span class="string">&#x27;a&#x27;</span>);             <span class="comment">// 生成key值</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,key);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key,<span class="number">64</span>,IPC_CREAT|IPC_EXCL|<span class="number">0666</span>);    <span class="comment">// 创建共享内存</span></span><br><span class="line">    <span class="keyword">if</span>(shmid&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EEXIST)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">            shmid = shmget(key,<span class="number">64</span>,<span class="number">0666</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;shimget err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,shmid);</span><br><span class="line">    <span class="type">char</span> * p = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);             <span class="comment">// 映射共享内存到进程地址空间</span></span><br><span class="line">    <span class="keyword">if</span>(p == (<span class="type">void</span>*)<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;hahaha&quot;</span>);                      <span class="comment">// 写入共享内存直接赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p);                           <span class="comment">// 读取共享内存输入赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br><span class="line">    shmdt(p);                              <span class="comment">// 解除映射</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);            <span class="comment">// 删除共享内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><ul><li>ipcs -m：查看系统中所有的共享内存信息。</li><li>ipcrm -m shmid：删除共享内存。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><p>要求： 通过共享内存实现进程间通信，一个进程从终端输入数据，另一个进程打印数据，循环执行，当输入quit时循环结束<br>提示：还记得共享内存的特点吗？</p></blockquote><ul><li>共享内存的实现需要注意同步机制。</li></ul><blockquote><p>输入端：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;./app&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,key);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key,<span class="number">64</span>,IPC_CREAT|IPC_EXCL|<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EEXIST)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">            shmid = shmget(key,<span class="number">64</span>,<span class="number">0666</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;shimget err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == (<span class="type">void</span>*)<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;flag)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p-&gt;buf);</span><br><span class="line">            p-&gt;flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p-&gt;buf,<span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出端：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;./app&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key,<span class="number">64</span>,<span class="number">0666</span>);</span><br><span class="line">    p = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == (<span class="type">void</span>*)<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p-&gt;buf,<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p-&gt;buf);</span><br><span class="line">            p-&gt;flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信号灯集"><a href="#信号灯集" class="headerlink" title="信号灯集"></a>信号灯集</h1><blockquote><p>信号灯集是指多个进程共享一组信号灯，信号灯集可以实现进程间通信。信号灯集由一组信号灯组成，每个信号灯都是一个整数，每个进程都可以对信号灯进行读、写操作。<br>信号灯就是信号量，信号灯集也就是信号量的集合。通过信号灯集可以实现共享内存的同步。</p></blockquote><h2 id="信号灯集的特点（了解）"><a href="#信号灯集的特点（了解）" class="headerlink" title="信号灯集的特点（了解）"></a>信号灯集的特点（<strong>了解</strong>）</h2><ol><li>信号灯集是一种最为灵活的进程间通信方式，信号灯集可以实现复杂的进程间通信。</li><li>信号灯集可以实现多个进程对同一资源的互斥访问，从而实现进程间的同步。</li><li>信号灯集可以实现多个进程之间的通信，信号灯集可以实现复杂的进程间通信。</li></ol><h2 id="信号灯集的实现"><a href="#信号灯集的实现" class="headerlink" title="信号灯集的实现"></a>信号灯集的实现</h2><blockquote><p>信号灯集的实现主要有以下几步：</p><ul><li>创建key值，ftok函数可以生成一个唯一的key值。</li><li>创建信号灯集，shmget函数可以创建或打开一个信号灯集。</li><li>初始化信号灯集</li><li>pv操作信号灯集</li><li>删除信号灯集，shmctl函数可以删除一个信号灯集。</li></ul></blockquote><h2 id="信号灯集的应用"><a href="#信号灯集的应用" class="headerlink" title="信号灯集的应用"></a>信号灯集的应用</h2><h3 id="创建key值-（同共享内存）"><a href="#创建key值-（同共享内存）" class="headerlink" title="创建key值 （同共享内存）"></a>创建key值 （同共享内存）</h3><h3 id="创建或打开信号灯集"><a href="#创建或打开信号灯集" class="headerlink" title="创建或打开信号灯集"></a>创建或打开信号灯集</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span><br></pre></td></tr></table></figure><ul><li>key: 信号灯集的key值，由ftok函数生成。</li><li>size: 信号灯集的大小，以字节为单位。</li><li>shmflg: 信号灯集的访问权限，IPC_CREAT（创建）|0666</li><li>返回值：成功返回信号灯集的ID，失败返回-1。</li></ul><h3 id="初始化或删除信号灯集"><a href="#初始化或删除信号灯集" class="headerlink" title="初始化或删除信号灯集"></a>初始化或删除信号灯集</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span></span><br></pre></td></tr></table></figure><ul><li>semid: 信号灯集的ID，由semget函数生成。</li><li>semnum: 信号灯的编号,要操作的信号灯的编号。</li><li>cmd: 操作命令<ul><li>IPC_RMID 删除信号灯集</li><li>SETVAL 设置信号灯的值</li><li>GETVAL 获取信号灯的值</li></ul></li><li>…: 信号灯的值，当cmd为SETVAL时，需要设置的值。</li><li>返回值：成功返回0，失败返回-1。</li></ul><p>共用体格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;    <span class="comment">/* 信号量初值 */</span>     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>;    <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_INFO */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;./app&quot;</span>,<span class="string">&#x27;a&#x27;</span>);             <span class="comment">// 生成key值</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,key);</span><br><span class="line">    <span class="type">int</span> semid = semget(key,<span class="number">64</span>,IPC_CREAT|IPC_EXCL|<span class="number">0666</span>);    <span class="comment">// 创建信号灯集</span></span><br><span class="line">    <span class="keyword">if</span>(semid&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EEXIST)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">            semid = semget(key,<span class="number">64</span>,<span class="number">0666</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;seimget err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span>;</span>                            <span class="comment">// 初始化信号灯集</span></span><br><span class="line">    sem.val = <span class="number">10</span>;</span><br><span class="line">    semctl(semid,<span class="number">0</span>,SETVAL,sem);</span><br><span class="line">    sem.val = <span class="number">0</span>;</span><br><span class="line">    semctl(semid,<span class="number">1</span>,SETVAL,sem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,semid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,semctl(semid,<span class="number">0</span>,GETVAL));    <span class="comment">// 获取信号灯的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,semctl(semid,<span class="number">1</span>,GETVAL));</span><br><span class="line">    semctl(semid,<span class="number">0</span>,IPC_RMID);                 <span class="comment">// 删除信号灯集</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pv操作信号灯集"><a href="#pv操作信号灯集" class="headerlink" title="pv操作信号灯集"></a>pv操作信号灯集</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span></span><br></pre></td></tr></table></figure><ul><li>semid: 信号灯集的ID，由semget函数生成。</li><li>sops: 信号灯操作数组，数组中每个元素都是一个信号灯操作结构体。</li><li>nsops: 信号灯操作数组的元素个数。</li><li>返回值：成功返回0，失败返回-1。</li></ul><blockquote><p>信号灯操作结构体：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> sem_num;    <span class="comment">/* 信号灯编号 */</span></span><br><span class="line">    <span class="type">short</span> sem_op;    <span class="comment">/* 操作类型 */</span></span><br><span class="line">    <span class="type">short</span> sem_flg;    <span class="comment">/* 标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>sem_num: 信号灯编号，要操作的信号灯的编号。</li><li>sem_op: 操作类型<ul><li>-1 申请资源 p操作</li><li>1 释放资源 v操作</li><li>0 等待，直到信号灯值变为0</li></ul></li><li>sem_flg: 标志，可以是IPC_NOWAIT、0，分别表示非阻塞操作、阻塞操作。</li></ul><blockquote><p>使用：</p></blockquote><p>p操作（申请资源）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">mysembuf.sem_op = <span class="number">-1</span>;</span><br><span class="line">mysembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line">semop(semid, &amp;mysembuf, <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>v操作（释放资源）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">mysembuf.sem_op = <span class="number">1</span>;</span><br><span class="line">mysembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line">semop(semid, &amp;mysembuf, <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了使代码更简洁，可以将函数进行封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sen_op</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> sem_num, <span class="type">int</span> sem_op, <span class="type">int</span> sem_flg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line">    mysembuf.sem_num = sem_num;</span><br><span class="line">    mysembuf.sem_op = sem_op;</span><br><span class="line">    mysembuf.sem_flg = sem_flg;</span><br><span class="line">    semop(semid, &amp;mysembuf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>pv操作的区别主要在于sem_op的取值，申请资源为-1，释放资源为1。</li></ul>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信之信号</title>
      <link href="/2024/08/05/IO%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E4%BF%A1%E5%8F%B7/"/>
      <url>/2024/08/05/IO%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><blockquote><ul><li>信号是在软件层次上对中断机制的一种模拟，是一种<strong>异步</strong>的通信方式。</li><li>信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。</li><li>如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</li></ul></blockquote><h1 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h1><p>在linux系统中，信号被分为可靠信号和不可靠信号。共64种，可通过<code>kill -l</code>命令查看。</p><ul><li>1-31：<strong>不可靠信号</strong>，也称为非实时信号，不支持排队，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次,由内核管理，用于进程间通信和同步。</li><li>32-64：<strong>可靠信号</strong>，也称为实时信号，支持排队，信号不会丢失，发多少次，就可以收到多少次，由用户进程管理，用于进程控制和错误通知。</li></ul><h1 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h1><ul><li>对于前台进程，用户输入特殊字符（如Ctrl+C、Ctrl+Z等）时，会产生信号。</li><li>在终端运行时kill命令或在程序中调用kill函数时，也会产生信号。</li><li>系统状态变化时，也会产生信号，如进程终止、资源耗尽等。</li></ul><h1 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h1><ul><li>忽略信号：忽略信号的目的是不处理该信号，让它继续传递到下一个进程。</li><li>捕捉信号：捕捉信号的目的是在信号发生时执行相应的操作，如终止进程、打印信息、忽略信号等。</li><li>执行默认操作：Linux系统中对每种信号规定了默认操作，即执行信号默认的功能。</li></ul><h1 id="常见的信号"><a href="#常见的信号" class="headerlink" title="常见的信号"></a>常见的信号</h1><table><thead><tr><th align="center">信号</th><th align="center">描述</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">SIGKILL</td><td align="center">结束进程，不能被忽略不能被捕捉</td><td align="center">9</td></tr><tr><td align="center">SIGSTOP</td><td align="center">结束进程，不能被忽略不能被捕捉</td><td align="center">19</td></tr><tr><td align="center">SIGCHLD</td><td align="center">子进程状态改变时给父进程发的信号,不会结束进程</td><td align="center">17</td></tr><tr><td align="center">SIGINT</td><td align="center">结束进程，对应快捷方式ctrl+c</td><td align="center">2</td></tr><tr><td align="center">SIGTSTP</td><td align="center">暂停信号，对应快捷方式ctrl+z</td><td align="center">20</td></tr><tr><td align="center">SIGQUIT</td><td align="center">退出信号，对应快捷方式ctrl+\</td><td align="center">3</td></tr><tr><td align="center">SIGALRM</td><td align="center">闹钟信号，alarm函数设置定时，当到设定的时间时，内核会向进程发送此信号结束进程。</td><td align="center">14</td></tr><tr><td align="center">SIGTERM</td><td align="center">结束终端进程，kill 使用时不加数字默认是此信号</td><td align="center">15</td></tr></tbody></table><h1 id="信号发送函数"><a href="#信号发送函数" class="headerlink" title="信号发送函数"></a>信号发送函数</h1><blockquote><h3 id="kill函数：用来向进程发送信号。"><a href="#kill函数：用来向进程发送信号。" class="headerlink" title="kill函数：用来向进程发送信号。"></a>kill函数：用来向进程发送信号。</h3></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line">    功能：信号发送</span><br><span class="line">    参数：pid：指定进程</span><br><span class="line">        sig：要发送的信号</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，错误原因存于errno</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="raise函数：用来向自身进程发送信号。"><a href="#raise函数：用来向自身进程发送信号。" class="headerlink" title="raise函数：用来向自身进程发送信号。"></a>raise函数：用来向自身进程发送信号。</h3></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line">    功能：信号发送</span><br><span class="line">    参数：sig：要发送的信号</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，错误原因存于errno</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><blockquote><h3 id="alarm函数：用来设置定时器。"><a href="#alarm函数：用来设置定时器。" class="headerlink" title="alarm函数：用来设置定时器。"></a>alarm函数：用来设置定时器。</h3></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"></span><br><span class="line">    功能：设置定时器，在指定的时间后向进程发送SIGALRM信号</span><br><span class="line">    参数：seconds：定时时间，单位为秒</span><br><span class="line">    返回值：如果调用此alarm()前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回<span class="number">0</span>。</span><br><span class="line">    注意：一个进程只能有一个闹钟时间。如果在调用alarm时</span><br><span class="line">    已设置过闹钟时间，则之前的闹钟时间被新值所代替</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h1><blockquote><h3 id="pause函数：用来挂起进程。"><a href="#pause函数：用来挂起进程。" class="headerlink" title="pause函数：用来挂起进程。"></a>pause函数：用来挂起进程。</h3></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    功能：挂起进程，直到收到信号</span><br><span class="line">    返回值：如果收到信号，则返回<span class="number">-1</span>，否则返回<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h1><blockquote><h3 id="signal函数：用来设置信号处理函数。"><a href="#signal函数：用来设置信号处理函数。" class="headerlink" title="signal函数：用来设置信号处理函数。"></a>signal函数：用来设置信号处理函数。</h3></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"></span><br><span class="line">    功能：信号处理函数</span><br><span class="line">    参数：  signum：要处理的信号</span><br><span class="line">            handler：信号处理方式</span><br><span class="line">                SIG_IGN：忽略信号</span><br><span class="line">                SIG_DFL：执行默认操作</span><br><span class="line">                handler：捕捉信号  </span><br><span class="line">               <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;&#125; <span class="comment">//函数名可以自定义</span></span><br><span class="line">    返回值：成功：设置之前的信号处理方式</span><br><span class="line">            失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="信号处理过程"><a href="#信号处理过程" class="headerlink" title="信号处理过程"></a>信号处理过程</h2><p>程序运行在用户空间时-&gt;进程由于系统调用或中断进入内核-&gt;转向用户空间执行信号处理函数-&gt;信号处理函数完毕后进入内核-&gt;返回用户空间继续执行程序</p>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信之序言与管道</title>
      <link href="/2024/08/05/IO%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%BA%8F%E8%A8%80%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
      <url>/2024/08/05/IO%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%BA%8F%E8%A8%80%E4%B8%8E%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><blockquote><p>早期的进程通信方式主要有以下几种：</p></blockquote><ol><li>无名管道（Pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。</li><li>命名管道（FIFO）：命名管道也是半双工的通信方式，但是它允许在不同机器上进行通信。</li><li>信号量（Semaphore）：信号量是一个计数器，用于控制多个进程对共享资源的访问。</li></ol><blockquote><p>现代的进程通信方式主要有以下几种：</p></blockquote><ol><li>消息队列（Message Queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>System V IPC：System V IPC 是一组函数库，提供了一系列的函数来进行进程间通信。它主要包括消息队列、共享内存和信号量。<ul><li>共享内存（Shared Memory）：共享内存就是映射一段能被其他进程所访问的内存，这段内存由一个进程创建，但多个进程可以访问。共享内存是最快的一种 IPC 方式，它克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>套接字（Socket）：套接字也是一种进程间通信机制，与其他 IPC 机制不同的是，它可用于不同机器间的进程通信。</li><li>信号灯集（Semaphore Set）：信号灯集是由一组互斥信号灯组成的集合，信号灯集用于控制对共享资源的访问。信号灯集克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li></ul></li></ol><h2 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h2><p>无名管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。</p><h3 id="创建无名管道"><a href="#创建无名管道" class="headerlink" title="创建无名管道"></a>创建无名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span><br><span class="line"></span><br><span class="line">    功能：创建无名管道</span><br><span class="line">    参数：pipefd[0] ：读端的文件描述符</span><br><span class="line">          pipefd[1] ：写端的文件描述符</span><br><span class="line">    返回值：成功返回 0，失败返回 -1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt;<span class="number">0</span>&gt;) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipefd[0] = %d, pipefd[1] = %d\n&quot;</span>, pipefd[<span class="number">0</span>], pipefd[<span class="number">1</span>]); <span class="comment">//3 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个管道，调用 pipe 函数，它会返回一个数组，数组的第一个元素是读端的文件描述符，第二个元素是写端的文件描述符。</li><li>调用 printf 函数，打印出 pipefd 数组的第一个元素和第二个元素。</li></ol><h3 id="读写特性"><a href="#读写特性" class="headerlink" title="读写特性"></a>读写特性</h3><ul><li>当管道中没有数据时，读进程会阻塞，直到有数据可读；将写端关闭，读操作会立即返回</li><li>管道写满（大小64k）时，写进程阻塞，一旦有4k空间可用（4k数据被读走），写进程才会被唤醒</li><li>只有在管道的读端存在时，向管道中写入数据才有意义。否则，会导致管道破裂，向管道中写入数据的进程将收到内核传来的SIGPIPE信号： (通常Broken pipe错误)。Broken pipe：管道破裂</li></ul><blockquote><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>创建子进程，父进程循环从终端输入字符串，子进程循环打印数据，当输入quit时程序结束。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            read(fd[<span class="number">0</span>],str,<span class="number">32</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(str,<span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;读取:%s\n&quot;</span>,str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            write(fd[<span class="number">1</span>],str,<span class="number">32</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(str,<span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;结束\n&quot;</span>);</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>有名管道也是一种半双工的通信方式，但是它允许在互不相关的两个进程间相互通信。</p><h3 id="创建有名管道"><a href="#创建有名管道" class="headerlink" title="创建有名管道"></a>创建有名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">    功能：创建有名管道</span><br><span class="line">    参数：pathname ：管道路径名</span><br><span class="line">          mode ：管道权限</span><br><span class="line">    返回值： 成功返回 <span class="number">0</span></span><br><span class="line">            失败返回 <span class="number">-1</span> 并设置errno号</span><br><span class="line">            当pathname已经存在时，返回错误，并设置errno号为EEXIST</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="容错判断："><a href="#容错判断：" class="headerlink" title="容错判断："></a>容错判断：</h3><p>当管道存在时，创建管道时会返回错误，errno为EEXIST；但并不影响后续操作，可以仅提示用户，无需结束程序。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mkfifo(<span class="string">&quot;fifo&quot;</span>,<span class="number">0666</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EEXIST)&#123;            <span class="comment">//管道存在可继续执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file exist\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                         <span class="comment">//其他错误报错结束程序</span></span><br><span class="line">        perror(<span class="string">&quot;mkfifo err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="读写特性-1"><a href="#读写特性-1" class="headerlink" title="读写特性"></a>读写特性</h3><ul><li>有名管道可以通过路径名来指出，并且在文件系统中可见，但内容存放在内存中。</li><li>进程通过文件IO来操作有名管道</li><li>有名管道遵循先进先出规则</li><li>不支持如lseek() 操作</li><li>只写方式打开有名管道，写进程阻塞（阻塞在文件打开时），直到有读进程打开</li><li>只读方式打开有名管道，读进程阻塞（阻塞在文件打开时），直到有写进程打开</li><li>可读可写方式打开有名管道，如果管道中没有数据，读进程阻塞</li></ul><blockquote><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>两个进程实现通信，一个进程输入字符串，另一个进程打印数据，当输入quit时结束</p></blockquote><h4 id="写进程"><a href="#写进程" class="headerlink" title="写进程"></a>写进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mkfifo(<span class="string">&quot;fifo&quot;</span>,<span class="number">0666</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EEXIST)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;file exist\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;fifo&quot;</span>,O_WRONLY);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        write(fd,buf,<span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,buf))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读进程"><a href="#读进程" class="headerlink" title="读进程"></a>读进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mkfifo(<span class="string">&quot;fifo&quot;</span>,<span class="number">0666</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EEXIST)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;file exist\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;fifo&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        read(fd,buf,<span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,buf))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;output:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="无名管道与有名管道的区别"><a href="#无名管道与有名管道的区别" class="headerlink" title="无名管道与有名管道的区别"></a>无名管道与有名管道的区别</h2><table><thead><tr><th align="center"></th><th align="center">无名管道</th><th align="center">有名管道</th></tr></thead><tbody><tr><td align="center">使用场景</td><td align="center">只能在亲缘关系进程</td><td align="center">不相关的任意进程</td></tr><tr><td align="center">读写位置</td><td align="center">有固定读端fd[0]写端fd[1]</td><td align="center">先进先出原则</td></tr><tr><td align="center">lseek操作</td><td align="center">不支持lseek操作</td><td align="center">不支持lseek操作</td></tr><tr><td align="center">数据存储位置</td><td align="center">数据存储在内核空间</td><td align="center">数据存储在内核空间</td></tr><tr><td align="center">操作类型</td><td align="center">文件IO进行操作</td><td align="center">文件IO进行操作</td></tr><tr><td align="center">在文件系统中是否存在</td><td align="center">否</td><td align="center">在文件系统中存在管道文件</td></tr><tr><td align="center">操作方式</td><td align="center">直接进行读写操作</td><td align="center">先打开管道文件，再读写</td></tr><tr><td align="center">函数</td><td align="center">pipe</td><td align="center">mkfifo</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>无名管道：半双工通信方式，只能在亲缘关系进程间通信，数据只能单向流动。</li><li>有名管道：半双工通信方式，可在任意进程间通信，数据先进先出。</li><li>无名管道与有名管道的区别：无名管道只能在亲缘关系进程间通信，数据只能单向流动；有名管道可在任意进程间通信，数据先进先出。</li><li>进程间通信方式：有名管道、无名管道、消息队列、共享内存、套接字、信号灯集。</li></ul>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO总结</title>
      <link href="/2024/08/03/IO%E8%BF%9B%E7%A8%8B/IO%E6%80%BB%E7%BB%93/"/>
      <url>/2024/08/03/IO%E8%BF%9B%E7%A8%8B/IO%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="文件IO与标准IO的区别"><a href="#文件IO与标准IO的区别" class="headerlink" title="文件IO与标准IO的区别"></a>文件IO与标准IO的区别</h1><table><thead><tr><th align="center"></th><th align="center">标准IO</th><th align="center">文件IO</th></tr></thead><tbody><tr><td align="center">概念</td><td align="center">c语言定义的标准输入输出</td><td align="center">posix定义的文件操作</td></tr><tr><td align="center">操作对象</td><td align="center">围绕文件流操作FILE*</td><td align="center">围绕文件描述符进行操作</td></tr><tr><td align="center">缓冲区</td><td align="center">有缓冲区</td><td align="center">无缓冲区</td></tr><tr><td align="center">默认开启</td><td align="center">开启三个流：stdin、stdout、stderr</td><td align="center">开启三个文件描述符：0（输入）、1（输出）、2（错误）</td></tr><tr><td align="center">操作类别</td><td align="center">只能操作普通文件</td><td align="center">可以操作除目录之外的所有文件</td></tr></tbody></table><h1 id="打开文件模式"><a href="#打开文件模式" class="headerlink" title="打开文件模式"></a>打开文件模式</h1><table><thead><tr><th align="center">文件IO模式</th><th align="center">标准IO模式</th></tr></thead><tbody><tr><td align="center">O_RDONLY</td><td align="center">“r”</td></tr><tr><td align="center">O_RDWR</td><td align="center">“r+”</td></tr><tr><td align="center">O_WEONLY &#124; O_CREATE &#124; O_TRUNC</td><td align="center">“w”</td></tr><tr><td align="center">O_RDWR &#124; O_TRUNC &#124; O_CREATE</td><td align="center">“w+”</td></tr><tr><td align="center">O_APPEND &#124; O_CREATE &#124; O_WEONLY</td><td align="center">“a”</td></tr><tr><td align="center">O_APPEND &#124; O_CREATE &#124; O_RDWR</td><td align="center">“a+”</td></tr></tbody></table><h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><blockquote><p>目录操作围绕目录流DIR*进行操作，目录流是由opendir()函数创建的，它可以用来遍历目录中的文件和子目录。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝线程</title>
      <link href="/2024/07/31/IO%E8%BF%9B%E7%A8%8B/%E6%B5%85%E5%B0%9D%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/07/31/IO%E8%BF%9B%E7%A8%8B/%E6%B5%85%E5%B0%9D%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><blockquote><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一个进程可以包含多个线程，每条线程并行执行不同的任务。线程间共享进程的内存空间和其他资源，因此，线程可以直接读写进程的数据。</p></blockquote><h1 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h1><ul><li>共同点：都为系统提供并发执行的能力</li><li>不同点：<ul><li>资源和调度：进程是系统资源分配的最小单位；线程是资源调度的最小单位。</li><li>地址空间：每个进程都有独立的地址空间；同一进程中的多个线程共享进程地址空间</li><li>通信方面：多线程的通信比较简单，借助全局变量，但是需要考虑临界资源的访问问题；多进程的通信比较复杂，需要借助3-4g的内核空间(共享的)来完成通信</li><li>安全性：进程相对安全，进程间空间独立，单个进程的退出不会影响其他进程；线程安全性相对较低，会随进程的结束而结束。</li></ul></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">功能：创建线程</span><br><span class="line">参数：thread：线程标识 (线程ID)</span><br><span class="line">      attr：线程属性， <span class="literal">NULL</span>：代表设置默认属性</span><br><span class="line">      start_routine：函数名：代表线程函数</span><br><span class="line">      arg：用来给前面函数传参</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：错误码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>编译时需要手动链接线程库 <code>gcc xx.c -lpthread</code></li></ul><blockquote><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3></blockquote><ul><li>向线程运行函数传递参数：<code>void *arg</code></li></ul><h4 id="只传递一个参数时："><a href="#只传递一个参数时：" class="headerlink" title="只传递一个参数时："></a>只传递一个参数时：</h4><blockquote><p>直接定义一个变量，在创建线程时，将变量地址作为参数传递给线程函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">NULL</span>,handler,&amp;a)!=<span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="传递多个参数时："><a href="#传递多个参数时：" class="headerlink" title="传递多个参数时："></a>传递多个参数时：</h4><blockquote><p>定义一个结构体，在创建线程时，将结构体的地址作为参数传递给线程函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">10</span>];</span><br><span class="line">&#125;my_struct;</span><br><span class="line"></span><br><span class="line">my_struct my_data;</span><br><span class="line">my_data.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(my_data.b,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">NULL</span>,handler,&amp;my_data)!=<span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"></span><br><span class="line">功能：退出线程</span><br><span class="line">参数：retval：线程退出时返回的值，<span class="literal">NULL</span>：代表线程正常退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h2 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h2></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line">- 功能：用于等待一个指定的线程结束，阻塞函数</span><br><span class="line">- 参数：thread：创建的线程对象</span><br><span class="line">      value_ptr：指针*value_ptr指向线程返回的参数</span><br><span class="line">- 返回值：成功 ： <span class="number">0</span></span><br><span class="line">         失败：errno</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">handler</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in handler%ld\n&quot;</span>,pthread_self());</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">NULL</span>,handler,<span class="literal">NULL</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main%ld\n&quot;</span>,pthread_self());</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);  <span class="comment">//等待线程结束 阻塞</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;join\n&quot;</span>);</span><br><span class="line">    <span class="comment">// while(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取线程ID"><a href="#获取线程ID" class="headerlink" title="获取线程ID"></a>获取线程ID</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">功能：获取当前线程的ID</span><br><span class="line">返回值：线程ID</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h2><blockquote><p>设置线程分离属性，保证子线程在退出时，系统会自动回收资源，不需要调用prhtread_join函数进行回收</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line">功能：让线程分离，不再受到父进程的控制，线程结束后资源由系统回收</span><br><span class="line">参数：thread：线程ID</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：错误码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>注意：</strong> 子线程在退出时，资源未被回收，线程会变为僵尸线程</li></ul><blockquote><p>使用方式：</p></blockquote><ul><li>在主线程中调用pthread_detach(tid);</li><li>在子进程中调用pthread_detach(pthread_self());</li></ul><blockquote><p><strong>注意：</strong></p><ul><li><p>1.如果线程已经设置了分离状态，则再调用pthread_join就会失败，因为线程已经退出了，资源已经回收了。</p></li><li><p>2.pthread_datach 和 pthread_join 如何选择？</p><ul><li>当主线程中希望有阻塞操作时，可以选择调用pthread_join函数回收线程</li><li>当主线程本身有循环操作，希望子线程在结束时立马回收线程可以选择pthread_detach设置分离属性</li></ul></li><li><p>3.设置线程的分离属性有两种方式：</p><ul><li>pthread_detach(tid)：设置线程tid的分离属性</li><li>pthread_create的第二个参数来设置分离属性</li></ul></li></ul></blockquote><h2 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h2><blockquote><p>线程取消是指当线程处于阻塞状态时，可以主动抛出取消异常，让线程退出阻塞状态，并执行线程取消的操作。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line">功能：取消线程</span><br><span class="line">参数：thread：线程ID</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：错误码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>注意：</strong> 线程取消后，线程仍然处于阻塞状态，需要调用pthread_join函数进行回收资源</li></ul><blockquote><p>使用方式：</p></blockquote><ul><li>在线程处于阻塞状态时，调用pthread_cancel函数取消线程</li><li>调用pthread_join函数回收资源</li></ul><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="同步的概念"><a href="#同步的概念" class="headerlink" title="同步的概念"></a>同步的概念</h2><blockquote><p>同步是指多个线程按照一定顺序执行，从而实现程序的正确性和有效性。</p></blockquote><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><blockquote><ul><li>信号量是一种同步机制，用于控制多个线程对共享资源的访问。就是一种实现线程间同步的方式。</li><li>由信号量来决定线城市继续运行还是等待，信号量表示一类资源，其值表示系统中该类资源的数量。</li><li>信号量是一个受保护的变量，只能通过初始化、P操作和V操作来操作访问。</li><li>信号量的值是一个非负整数</li></ul></blockquote><h3 id="初始化信号量"><a href="#初始化信号量" class="headerlink" title="初始化信号量"></a>初始化信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line">功能：初始化信号量</span><br><span class="line">参数：sem：信号量标识</span><br><span class="line">      pshared：是否为进程间共享，<span class="number">0</span>：否，<span class="number">1</span>：是</span><br><span class="line">      value：信号量初始值</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="p操作（申请资源）"><a href="#p操作（申请资源）" class="headerlink" title="p操作（申请资源）"></a>p操作（申请资源）</h3><blockquote><p>P操作是对信号量的一种操作，用来将信号量的值减1，如果信号量的值大于0，则允许线程继续运行，否则，线程阻塞，直到其他线程释放了信号量。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line">功能：申请资源</span><br><span class="line">参数：sem：信号量标识</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：错误码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v操作（释放资源）"><a href="#v操作（释放资源）" class="headerlink" title="v操作（释放资源）"></a>v操作（释放资源）</h3><blockquote><p>V操作是对信号量的一种操作，用来将信号量的值加1，如果有线程正在等待该信号量，则唤醒该线程，使其继续运行。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line">功能：释放资源</span><br><span class="line">参数：sem：信号量标识</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="信号量的分类"><a href="#信号量的分类" class="headerlink" title="信号量的分类"></a>信号量的分类</h3><ul><li>1.posix信号量：是由pthread库提供的信号量，是系统调用接口，只能在pthread程序中使用。<ul><li>a.无名信号量：只能在同一进程内使用，只能在同一线程内使用。<ul><li>函数接口：sem_init\sem_wait\sem_post</li></ul></li><li>b.有名信号量：可以跨越多个进程，可以跨越多个线程。<ul><li>函数接口：sem_open\sem_close\sem_wait\sem_post</li></ul></li></ul></li><li>2.System V信号量：是由系统调用接口提供的信号量，只能在unix系统中使用。<ul><li>函数接口：semget\semop\semctl</li></ul></li></ul><h3 id="信号量的使用示例"><a href="#信号量的使用示例" class="headerlink" title="信号量的使用示例"></a>信号量的使用示例</h3><blockquote><p>通过信号量实现线程同步：主线程循环从终端输入字符串，子线程循环将字符串打印至终端，当输入”quit”时结束</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">sem_t</span> sem ;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,a))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);</span><br><span class="line">        sem_wait(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sem_init(&amp;sem,<span class="number">0</span>,<span class="number">0</span>)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pthread_t</span> tid ;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,a))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        sem_post(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h2><blockquote><p>互斥是指多个线程在同一时间只能有一个线程对共享资源进行访问，其他线程必须等待。其实同步也是一种互斥，只是同步是多个线程按照一定顺序执行，而互斥无序执行。</p></blockquote><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><blockquote><p>通过互斥锁可以实现互斥机制，主要用来保护临界资源，每个临界资源都由一个互斥锁来保护，线程必须先获得互斥锁才能访问临界资源，访问完资源后释放该锁。如果无法获得锁，线程会阻塞直到获得锁为止。</p></blockquote><blockquote><p>互斥锁的基本操作方式：</p></blockquote><ul><li>1.初始化互斥锁：pthread_mutex_init</li><li>2.申请互斥锁（上锁）阻塞：pthread_mutex_lock</li><li>3.释放互斥锁（解锁）非阻塞：pthread_mutex_unlock</li></ul><h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><h4 id="初始化互斥锁"><a href="#初始化互斥锁" class="headerlink" title="初始化互斥锁"></a>初始化互斥锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line">功能：初始化互斥锁</span><br><span class="line">参数：mutex：互斥锁标识</span><br><span class="line">      attr：互斥锁属性，<span class="literal">NULL</span>：代表设置默认属性</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="申请互斥锁"><a href="#申请互斥锁" class="headerlink" title="申请互斥锁"></a>申请互斥锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line">功能：获得互斥锁</span><br><span class="line">参数：mutex：互斥锁标识</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="释放互斥锁"><a href="#释放互斥锁" class="headerlink" title="释放互斥锁"></a>释放互斥锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line">功能：释放互斥锁</span><br><span class="line">参数：mutex：互斥锁标识</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="销毁互斥锁"><a href="#销毁互斥锁" class="headerlink" title="销毁互斥锁"></a>销毁互斥锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line">功能：销毁互斥锁</span><br><span class="line">参数：mutex：互斥锁标识</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="互斥锁的使用示例"><a href="#互斥锁的使用示例" class="headerlink" title="互斥锁的使用示例"></a>互斥锁的使用示例</h4><blockquote><p>通过互斥锁实现线程互斥：主线程循环从终端输入字符串，子线程循环将字符串打印至终端，当输入”quit”时结束</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex ;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,a))        <span class="comment">// 判断输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);  <span class="comment">// 上锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);               <span class="comment">// 退出线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>)!=<span class="number">0</span>)    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pthread_t</span> tid ;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>)!=<span class="number">0</span>)&#123;    <span class="comment">// 创建线程</span></span><br><span class="line">        perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,a))       <span class="comment">// 循环输入 输入“quit”结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);            <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);      <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p></blockquote><h3 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h3><ul><li>1.资源分配不当：进程申请资源后，没有按照顺序获得资源，导致资源永远分配不到，造成死锁。</li><li>2.进程推进顺序不当：进程申请资源后，资源被其他进程占用，导致死锁。</li><li>3.资源循环等待：进程申请资源后，资源被其他进程占用，导致死锁。</li></ul><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul><li>1.资源分配：保证资源分配合理，避免资源的长期占用，降低死锁发生的概率。</li><li>2.进程推进顺序：保证进程申请资源的顺序合理，避免进程推进顺序不当，降低死锁发生的概率。</li><li>3.资源回收：进程释放资源后，及时释放资源，避免资源长期占用，降低死锁发生的概率。</li><li>4.超时等待：设置超时等待时间，避免进程无限等待，降低死锁发生的概率。</li></ul><h3 id="死锁检测与解除"><a href="#死锁检测与解除" class="headerlink" title="死锁检测与解除"></a>死锁检测与解除</h3><ul><li>1.死锁检测：检测系统是否存在死锁，并给出死锁的进程和资源。</li><li>2.死锁解除：通过进程回滚或资源回收，解除死锁。</li></ul><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a><strong>死锁产生的必要条件</strong></h3><ul><li>1.互斥使用：进程对资源的使用是互斥的，即在一段时间内某资源只能由一个进程占用。</li><li>2.请求和保持：进程已经获得了至少一个资源，但又提出新的资源申请，而该资源已被其他进程占用。</li><li>3.不可抢占：进程获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由自己释放。</li><li>4.循环等待：在发生死锁时，必然存在一个进程——资源的环形链。</li></ul><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><blockquote><p>条件变量是一种同步机制，用于线程间通信。条件变量允许一个线程等待某个条件，直到另一个线程发出信号。与互斥锁搭配使用，可以实现线程间的同步。  </p></blockquote><h3 id="条件变量的基本操作方式："><a href="#条件变量的基本操作方式：" class="headerlink" title="条件变量的基本操作方式："></a>条件变量的基本操作方式：</h3><blockquote><ul><li>1.初始化条件变量：pthread_cond_init</li><li>2.等待条件变量：pthread_cond_wait</li><li>3.产生条件变量：pthread_cond_signal</li></ul></blockquote><h4 id="初始化条件变量"><a href="#初始化条件变量" class="headerlink" title="初始化条件变量"></a>初始化条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line">功能：初始化条件变量</span><br><span class="line">参数：cond：条件变量标识</span><br><span class="line">      attr：条件变量属性，<span class="literal">NULL</span>：代表设置默认属性</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="等待条件变量"><a href="#等待条件变量" class="headerlink" title="等待条件变量"></a>等待条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line">功能：等待条件变量</span><br><span class="line">参数：cond：条件变量标识</span><br><span class="line">      mutex：互斥锁标识</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="产生条件变量"><a href="#产生条件变量" class="headerlink" title="产生条件变量"></a>产生条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line">功能：产生条件变量</span><br><span class="line">参数：cond：条件变量标识</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="销毁条件变量"><a href="#销毁条件变量" class="headerlink" title="销毁条件变量"></a>销毁条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line">功能：销毁条件变量</span><br><span class="line">参数：cond：条件变量标识</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">     失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>注意</em>：</p><ul><li><p>当没有条件变量产生时，pthread_cond_wait会造成阻塞，同时将锁解开；如果等到条件变量产生，pthread_cond_wait会结束阻塞，并重新上锁。</p></li><li><p>pthread_cond_wait阻塞状态是等待pthread_cond_signal唤醒</p></li><li><p>pthread_cond_signal只能唤醒单个cond_wait，相当于一对一；</p></li><li><p>pthread_cond_broadcast可以唤醒多个cond_wait,相当于一对多（广播）。</p></li></ul><h3 id="条件变量的使用示例"><a href="#条件变量的使用示例" class="headerlink" title="条件变量的使用示例"></a>条件变量的使用示例</h3><blockquote><p><strong>注意注意注意</strong>：<em>虽然有点扯，为了给自己整明白直接实况再现一下</em></p></blockquote><ul><li>时间轴上来说，得先等待条件变量，才能接受后发出的条件变量，如果之前有发出的条件变量，就时无效的算噪音。</li><li><em>就像你这会儿不想找对象（不等待条件变量），突然有个人找你处（发出了条件变量），肯定是不接受（你都不等待怎么拿）；得等你想处的时候（开始等待条件变量），这时候之前的话就不算了（早发出的条件变量失效）得再等一个（需要接收开始等待之后发出的条件变量）。</em> <blockquote><p>就像这：两个线程，一个线程倒置全局数组中的数，另一个线程遍历数组中数据,每隔1s遍历打印一次。要求：实现倒置一次，打印一次，顺序执行</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond, cond1;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">swap_handler</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">            pthread_cond_wait(&amp;cond1, &amp;lock);  <span class="comment">// 等待在这之后发出的条件变量（上下两函数一样的）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t = arr[i];</span><br><span class="line">            arr[i] = arr[<span class="number">9</span>-i];</span><br><span class="line">            arr[<span class="number">9</span>-i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        pthread_cond_signal(&amp;cond);    <span class="comment">//在这里早发出了一个条件变量，但这时候没有人等待所以无效</span></span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">print_handler</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="comment">// 等待条件变量</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        pthread_cond_signal(&amp;cond1);</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;t1, <span class="literal">NULL</span>, swap_handler, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;create thread1 error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;t2, <span class="literal">NULL</span>, print_handler, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;create thread2 error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mutext init error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_cond_init(&amp;cond, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;cond init error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pthread_cond_init(&amp;cond1, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;cond1 init error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>通过条件变量实现线程间通信：主线程循环从终端输入字符串，子线程循环将字符串打印至终端，当输入”quit”时结束</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex ;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond ;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,a))        <span class="comment">// 判断输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);  <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,a))    <span class="comment">// 等待条件变量</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);  <span class="comment">// 等待条件变量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);               <span class="comment">// 退出线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>)!=<span class="number">0</span>)    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pthread_cond_init(&amp;cond,<span class="literal">NULL</span>)!=<span class="number">0</span>)    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pthread_t</span> tid ;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>)!=<span class="number">0</span>)&#123;    <span class="comment">// 创建线程</span></span><br><span class="line">        perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>,a))       <span class="comment">// 循环输入 输入“quit”结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);  <span class="comment">// 上锁</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);  <span class="comment">// 产生条件变量</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);            <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);      <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);      <span class="comment">// 销毁条件变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝进程</title>
      <link href="/2024/07/31/IO%E8%BF%9B%E7%A8%8B/%E6%B5%85%E5%B0%9D%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/07/31/IO%E8%BF%9B%E7%A8%8B/%E6%B5%85%E5%B0%9D%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><blockquote><p>程序：</p></blockquote><ul><li>是指一个静态的代码文件，它是一组指令，用于完成特定任务。</li><li>存放在磁盘上的指令和数据的有序集合。</li><li>就是编译好的可执行文件。</li></ul><blockquote><p>进程：</p></blockquote><ul><li>是指程序的运行实例，是系统资源分配和调度的基本单位。</li><li>它是程序在执行过程中分配和使用的资源的集合。</li><li>进程是程序的一次执行过程。</li><li>进程是动态的，包括创建、调度、执行、消亡等过程。</li></ul><h2 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h2><ul><li>动态性：进程是动态的，它是程序的一次执行过程，是系统资源分配和调度的基本单位。</li><li>并发性：多个进程可以同时执行。</li></ul><h2 id="系统调度进程的特点"><a href="#系统调度进程的特点" class="headerlink" title="系统调度进程的特点"></a>系统调度进程的特点</h2><ol><li>时间片轮转法：系统将所有进程按先来先服务的原则排成一个队列，每个进程被分配一个时间片，时间片用完后进程切换到下一个进程。</li><li>系统为每个进程分配0-4GB的虚拟空间，其中0-3GB为用户空间；3GB-4GB为内核空间，所有进程共享。</li></ol><h2 id="进程段"><a href="#进程段" class="headerlink" title="进程段"></a>进程段</h2><ul><li>代码段（正文段）：存放程序代码。</li><li>数据段：存放的是全局变量、常数、以及动态数据分配的数据空间(如malloc函数取得的空间)等</li><li>堆栈段：存放函数返回的地址、函数的参数、局部变量。</li></ul><h2 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h2><h3 id="交互进程"><a href="#交互进程" class="headerlink" title="交互进程"></a>交互进程</h3><ul><li>该类进程是由shell控制和运行的。交互进程既可以在前台运行，也可以在后台运行。该类进程经常与用户进行交互，需要等待用户的输入，当接收到用户的输入后，该类进程会立刻响应，典型的交互式进程有：shell命令进程、文本编辑器等。<br>就是<strong>用户通过键盘、鼠标等方式与操作系统进行交互的进程</strong>。</li></ul><h3 id="批处理进程"><a href="#批处理进程" class="headerlink" title="批处理进程"></a>批处理进程</h3><ul><li>该类进程是由操作系统自动调度和运行的。批处理进程是指系统自动执行的程序，它是系统的核心，负责完成系统的初始化、资源分配、调度、以及系统的关闭等工作。批处理进程的特点是运行结束后，自动结束，不等待用户的输入。典型的批处理进程有：编译程序、打印机后台处理程序、系统维护程序等。</li></ul><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul><li>该类进程在后台运行。它一般在Linux启动时开始执行，系统关闭时才结束</li><li>ps -aux 查看进程信息中 ? 部分是守护进程</li></ul><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="运行态（TASK-RUNNING）：R"><a href="#运行态（TASK-RUNNING）：R" class="headerlink" title="运行态（TASK_RUNNING）：R"></a>运行态（TASK_RUNNING）：R</h3><ul><li>指正在被CPU运行或者就绪的状态。这样的进程被成为runnning进程。</li></ul><h3 id="睡眠态-等待态"><a href="#睡眠态-等待态" class="headerlink" title="睡眠态(等待态)"></a>睡眠态(等待态)</h3><h4 id="可中断睡眠态（TASK-INTERRUPTIBLE）S"><a href="#可中断睡眠态（TASK-INTERRUPTIBLE）S" class="headerlink" title="可中断睡眠态（TASK_INTERRUPTIBLE）S"></a>可中断睡眠态（TASK_INTERRUPTIBLE）S</h4><ul><li>处于等待状态中的进程，一旦被该进程等待的资源被释放，那么该进程就会进入运行状态。</li></ul><h4 id="不可中断睡眠态（TASK-UNINTERRUPTIBLE）D"><a href="#不可中断睡眠态（TASK-UNINTERRUPTIBLE）D" class="headerlink" title="不可中断睡眠态（TASK_UNINTERRUPTIBLE）D"></a>不可中断睡眠态（TASK_UNINTERRUPTIBLE）D</h4><ul><li><em>只能通过特定的函数进行唤醒，是不能随便去中断的</em></li><li>该状态的进程只能用**wake_up()**函数唤醒。</li></ul><h3 id="暂停态（TASK-STOPPED）-T"><a href="#暂停态（TASK-STOPPED）-T" class="headerlink" title="暂停态（TASK_STOPPED）:T"></a>暂停态（TASK_STOPPED）:T</h3><ul><li>当进程收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时就会进入暂停状态。可向其发送SIGCONT信号让进程转换到可运行状态。</li></ul><h3 id="死亡态：X"><a href="#死亡态：X" class="headerlink" title="死亡态：X"></a>死亡态：X</h3><ul><li>进程结束</li></ul><h3 id="僵尸态：Z"><a href="#僵尸态：Z" class="headerlink" title="僵尸态：Z"></a>僵尸态：Z</h3><ul><li>当进程已经终止运行，但还占用系统资源，要避免僵尸态的产生</li></ul><h3 id="进程其他状态"><a href="#进程其他状态" class="headerlink" title="进程其他状态"></a>进程其他状态</h3><table><thead><tr><th align="center">状态</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">高优先级</td></tr><tr><td align="center">N</td><td align="center">低优先级</td></tr><tr><td align="center">s</td><td align="center">会话组组长</td></tr><tr><td align="center">l</td><td align="center">多线程</td></tr><tr><td align="center">+</td><td align="center">前台进程</td></tr></tbody></table><h2 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><p><img src="https://s2.loli.net/2024/07/31/8XEf7BqVPpwLmGh.png" alt="状态转换图.png"></p><h3 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h3><ul><li>当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</li></ul><h3 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h3><ul><li>当进程已获得处理机（CPU），其程序正在处理机上执行，此时的进程状态称为执行状态。</li></ul><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><ul><li>正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。例如，等待I&#x2F;O完成、申请缓冲区不能满足、等待信件(信号)等。</li></ul><h1 id="进程函数"><a href="#进程函数" class="headerlink" title="进程函数"></a>进程函数</h1><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><blockquote><p>fork()：创建子进程，返回子进程的PID。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>子进程几乎拷贝了父进程的全部内容。包括代码、数据、系统数据段中的pc值、栈中的数据、父进程中打开的文件等；但它们的PID、PPID是不同的。</li><li>父子进程有独立的地址空间，互不影响；当在相应的进程中改变全局变量、静态变量，都互不影响。</li><li>若父进程先结束，子进程成为孤儿进程，被init进程收养，子进程变成后台进程。<br><img src="https://s2.loli.net/2024/07/31/pzh9G4WXycj5JHV.png" alt="进程的老祖.png"></li><li>若子进程先结束，父进程如果没有及时回收，子进程变成僵尸进程(要避免僵尸进程产生)</li></ol><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><blockquote><p>等待子进程结束，返回子进程的终止状态。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><ul><li>功能：回收子进程资源，阻塞函数，等待子进程退出后结束阻塞</li><li>参数：status：子进程退出状态，不接受子进程状态设为NULL</li><li>返回值：<ul><li>成功：回收的子进程的进程号</li><li>失败：-1</li></ul></li></ul><blockquote><p>示例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程等待子进程结束，子进程睡眠2秒后结束，父进程打印父进程信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h3><blockquote><p>等待子进程结束，返回子进程的终止状态。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><ul><li>功能：回收子进程资源，阻塞函数，等待子进程退出后结束阻塞</li><li>参数：<ul><li>pid：等待的子进程的进程号，-1表示任意子进程</li><li>status：子进程退出状态，不接受子进程状态设为NULL</li><li>options：可选参数，取值如下：<ul><li>0:阻塞直到子进程结束</li><li>WNOHANG：若没有子进程退出，则立即返回，非阻塞。</li></ul></li></ul></li><li>返回值：<ul><li>成功：回收的子进程的进程号</li><li>当选项为WNOHANG时，若没有子进程退出，则返回0，否则返回子进程的进程号</li><li>失败：-1</li></ul></li></ul><blockquote><p>示例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> <span class="type">const</span> *argv[])</span>&#123;</span><br><span class="line">    pid t pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork err&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid ==<span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in the child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>,WNOHANG)!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in the parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>无论哪一种阻塞方式都有他们的缺点：</p></blockquote><ul><li>非阻塞：轮询就是循环执行，这种循环执行就会一直占用的你的CPU，消耗CPU资源</li><li>阻塞：实时性差我的代码在这里阻塞，就会造成进程阻塞，导致代码无法执行</li></ul><blockquote><p><code>wait(NULL)</code>等价于<code>waitpid(pid, NULL, 0)</code></p></blockquote><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><blockquote><p>exit()与_exit()：终止进程。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;<span class="comment">//刷新缓存</span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);<span class="comment">//不刷新缓存</span></span><br></pre></td></tr></table></figure><ul><li>exit()：<ul><li>功能：终止进程，释放资源，返回给父进程。</li><li>参数：status：进程退出状态，通常为0。</li></ul></li><li>_exit()：<ul><li>功能：终止进程，释放资源，不返回给父进程。</li><li>参数：status：进程退出状态，通常为0。</li></ul></li></ul><blockquote><p>示例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出hello，然后进程结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>exit和return区别：</p></blockquote><ul><li>exit：不管在子函数还是主函数，都可以结束进程</li><li>return：当子函数中有return时返回到函数调用位置，并不结束进程</li></ul><h2 id="获取进程号"><a href="#获取进程号" class="headerlink" title="获取进程号"></a>获取进程号</h2><blockquote><p>getpid()：获取进程号。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>功能：获取当前进程的进程号。</li><li>返回值：当前进程的进程号。</li></ul><blockquote><p>getppid()：获取父进程号。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>功能：获取当前进程的父进程号。</li><li>返回值：当前进程的父进程号。</li></ul><blockquote><p>示例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid:%d,ppid:%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出pid和ppid</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="守护进程-1"><a href="#守护进程-1" class="headerlink" title="守护进程"></a>守护进程</h1><h2 id="守护进程特点"><a href="#守护进程特点" class="headerlink" title="守护进程特点"></a>守护进程特点</h2><ul><li>生命周期较长，在系统启动时开启，系统关闭退出</li><li>是一个后台进程</li><li>不依赖于控制终端，且周期性执行的一个进程</li></ul><h2 id="守护进程实现"><a href="#守护进程实现" class="headerlink" title="守护进程实现"></a>守护进程实现</h2><ul><li>fork()：创建子进程，父进程退出，子进程成为孤儿进程，由init进程接管</li><li>setsid()：创建新的会话，成为新的进程组的组长，并与原来的进程组、控制终端脱离</li><li>chdir()：改变工作目录到根目录 chdir(“&#x2F;“)</li><li>umask()：设置文件创建掩码 umask(0)</li><li>close()：关闭文件描述符 0、1、2</li></ul><blockquote><p>示例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//在进程中创建新会话</span></span><br><span class="line">        setsid();</span><br><span class="line">        <span class="comment">//改变工作目录到根目录</span></span><br><span class="line">        chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//设置文件创建掩码</span></span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//关闭文件描述符</span></span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)          </span><br><span class="line">    &#125;<span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>练习：守护进程循环1s向文件中写入字符“hello”。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        setsid();</span><br><span class="line">        chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;/home/hq/work/process/tt.c&quot;</span>,O_WRONLY);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            write(fd,<span class="string">&quot;hello\n&quot;</span>,<span class="number">6</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO终章之库</title>
      <link href="/2024/07/30/IO%E8%BF%9B%E7%A8%8B/IO%E7%BB%88%E7%AB%A0%E4%B9%8B%E5%BA%93/"/>
      <url>/2024/07/30/IO%E8%BF%9B%E7%A8%8B/IO%E7%BB%88%E7%AB%A0%E4%B9%8B%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><blockquote><p>当使用别人的函数时除了包含库文件之外还要有库文件。</p></blockquote><h2 id="库的定义"><a href="#库的定义" class="headerlink" title="库的定义"></a>库的定义</h2><blockquote><p>库是一些常用函数的目标文件集合，提供相应函数的接口，便于使用。<br>库本质上就是一种可执行代码的二进制形式。<br>linux系统中，库的后缀名为.so，windows系统中，库的后缀名为.dll。<br>由于不同系统的库文件格式不同，因此在不同系统库的二进制文件之间不能直接运行。</p></blockquote><h2 id="库的分类"><a href="#库的分类" class="headerlink" title="库的分类"></a>库的分类</h2><blockquote><p>库分为动态库和静态库。本质区别在于<strong>代码被载入的时刻不同</strong>。</p></blockquote><ul><li><p>动态库：在程序运行时才载入，程序运行时才链接到库文件，程序运行结束后才释放。</p><ol><li><p>优点：</p><ul><li>程序在执行时加载动态库，代码体积小；</li><li>程序升级简单；</li><li>不同应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例；</li></ul></li><li><p>缺点：</p><ul><li>程序运行时还需要动态库的存在，移植性较差</li></ul></li></ol></li><li><p>静态库：静态库在程序编译时会被链接到目标代码中；</p><ol><li>优点：程序运行时将不再需要该静态库；运行时无需加载库，运行速度更快；</li><li>缺点：<ul><li>静态库中的代码复制到了程序中，因此体积较大；</li><li>静态库升级后，程序需要重新编译链接；</li></ul></li></ol></li></ul><h2 id="库的制作"><a href="#库的制作" class="headerlink" title="库的制作"></a>库的制作</h2><blockquote><p>库的制作需要使用到编译器。</p></blockquote><h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h3><blockquote><p>静态库的制作需要使用到ar命令。</p></blockquote><h4 id="静态库的编译"><a href="#静态库的编译" class="headerlink" title="静态库的编译"></a>静态库的编译</h4><ol><li><p>编写源文件，并在源文件中包含需要导出的函数。</p></li><li><p>使用编译器编译源文件，生成目标文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c xxx.c -o xxx.o</span><br></pre></td></tr></table></figure></li><li><p>使用ar命令将目标文件打包成静态库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar crs libxxx.a xxx.o </span><br></pre></td></tr></table></figure><ul><li>crs：创建静态库，并将目标文件添加到静态库中；</li><li>libxxx.a：静态库的名称；lib为前缀，a为后缀；xxx为自定义名称；</li></ul></li></ol><h4 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h4><ol><li><p>编写程序，包含静态库的头文件。</p></li><li><p>使用编译器编译程序，生成可执行文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L. -lxxx -o main</span><br></pre></td></tr></table></figure><ul><li>-L.：指定静态库的搜索路径；(~不会被展开)</li><li>-lxxx：指定静态库的名称；（小写L）</li></ul></li><li><p>运行可执行文件。</p></li></ol><h3 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h3><blockquote><p>动态库的制作使用gcc编译器。</p></blockquote><h4 id="动态库的编译"><a href="#动态库的编译" class="headerlink" title="动态库的编译"></a>动态库的编译</h4><ol><li><p>编写源文件，并在源文件中包含需要导出的函数。</p></li><li><p>使用编译器编译源文件，生成目标文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c xxx.c -o xxx.o</span><br></pre></td></tr></table></figure></li><li><p>使用编译器将目标文件打包成动态库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fpic -shared -o libxxx.so xxx.o</span><br></pre></td></tr></table></figure><ul><li>-fpic：生成位置无关代码；</li><li>-shared：生成动态库；</li><li>o libxxx.so：指定动态库的名称；lib为前缀，so为后缀；xxx为自定义名称；</li></ul></li></ol><h4 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h4><ol><li><p>编写程序，包含动态库的头文件。</p></li><li><p>使用编译器编译程序，生成可执行文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L. -lxxx.so -o main</span><br></pre></td></tr></table></figure></li><li><p>运行可执行文件。</p><ul><li>可以正常编译通过，但是运行时报错<br> .&#x2F;a.out: error while loading shared libraries: libmyadd.so: cannot open shared object file: No such file or directory</li></ul><p> 原因：当加载动态库时，系统会默认从&#x2F;lib或&#x2F;usr&#x2F;lib路径下查找库文件</p><p> 解决方法（有三种）：<br> (1)把库拷贝到&#x2F;usr&#x2F;lib和&#x2F;lib目录下。(此方法编译时不需要指定库的路径)<br> (2)在LD_LIBRARY_PATH环境变量中加上库所在路径。<br>     export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:.<br>     （终端关闭，环境变量就没在了）<br> (3) 添加&#x2F;etc&#x2F;ld.so.conf.d&#x2F;*.conf文件。把库所在的路径加到文件末尾，并执行 ldconfig刷新<br>         sudo vi xx.conf<br> 添加动态库存在的路径使用绝对路径</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目录操作</title>
      <link href="/2024/07/30/IO%E8%BF%9B%E7%A8%8B/%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/30/IO%E8%BF%9B%E7%A8%8B/%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a><strong>目录操作</strong></h1><blockquote><p>围绕目录流进行操作，DIR *</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">功能：获得目录流</span><br><span class="line">参数：要打开的目录</span><br><span class="line">返回值：成功：目录流</span><br><span class="line">       失败：<span class="literal">NULL</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">功能：读目录</span><br><span class="line">参数：要读的目录流</span><br><span class="line">返回值：成功：读到的信息    </span><br><span class="line">      失败或读到目录结尾：<span class="literal">NULL</span></span><br><span class="line">返回值为结构体，该结构体成员为描述该目录下的文件信息</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">        <span class="type">ino_t</span>   d_ino;                   <span class="comment">/* 索引节点号*/</span></span><br><span class="line">        <span class="type">off_t</span>   d_off;               <span class="comment">/*在目录文件中的偏移*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* 文件名长度*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* 文件类型 */</span></span><br><span class="line">        <span class="type">char</span>    d_name[<span class="number">256</span>];      <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">功能：关闭目录</span><br><span class="line">参数：dirp：目录流</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">       失败：<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用示例：使用目录操作实现<strong>ls</strong>命令</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;.&quot;</span>);             <span class="comment">//打开当前目录</span></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;opendir error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">d</span>;</span>                   <span class="comment">//目录结构体</span></span><br><span class="line">    <span class="keyword">while</span> ((d = readdir(dir))!=<span class="literal">NULL</span>)    <span class="comment">//读取目录</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d-&gt;d_name[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>)             <span class="comment">//跳过隐藏文件</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,d-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);                       <span class="comment">//关闭目录</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件IO</title>
      <link href="/2024/07/29/IO%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6IO/"/>
      <url>/2024/07/29/IO%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h1><p>文件IO（File Input&#x2F;Output）是在posix系统（可移植操作系统接口）中定义的一组输入输出函数，用于操作文件。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h1><ul><li><p>没有缓冲机制：文件IO是直接与磁盘打交道，没有缓冲机制，每次读写都需要实际的磁盘I&#x2F;O操作。</p></li><li><p>围绕<strong>文件描述符</strong>进行操作，文件描述符是非负数，用于标识打开的文件。0、1、 2…</p></li><li><p>默认打开三个文件描述符：标准输入（0）、标准输出（1）、标准错误（2）。</p></li><li><p>除目录外，所有文件都可以进行读写操作。</p></li></ul><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a><strong>常用函数</strong></h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><blockquote><p>open()：打开文件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags，...)</span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    <span class="number">1.</span> pathname：文件路径。</span><br><span class="line">    <span class="number">2.</span> flags：打开方式，可以是以下值：</span><br><span class="line">        - O_RDONLY：只读。</span><br><span class="line">        - O_WRONLY：只写。</span><br><span class="line">        - O_RDWR：读写。</span><br><span class="line">        - O_CREAT：如果文件不存在，则创建。</span><br><span class="line">        - O_APPEND：追加。</span><br><span class="line">        - O_TRUNC: 清空文件。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：文件描述符。</span><br><span class="line">    失败：<span class="number">-1</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;./test.c&quot;</span>, O_CREAT | O_RDWR | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;打开失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件描述符：%d\n&quot;</span>, fd);<span class="comment">// 输出文件描述符 3</span></span><br><span class="line">close(fd);</span><br><span class="line"></span><br></pre></td></tr></table></figure><dl><dt>打开方式为O_CREAT | O_RDWR | O_TRUNC，<br>表示如果文件不存在，则创建，如果文件存在，则打开文件进行读写，并清空文件内容。<br>当打开方式有创建时，就要传递三个参数，也就是指定权限。这里使用0666。（八进制）<br>实际权限的计算方式：</dt><dd>（指定权限值）&amp;（~umask）&#x3D;（实际权限值）。<strong>umask值</strong>为0002，可以通过umask命令查看。</dd></dl><table><thead><tr><th align="center">指定权限值</th><th align="center">~umask值</th><th align="center">实际权限值</th></tr></thead><tbody><tr><td align="center">110 110 110</td><td align="center">111 111 101</td><td align="center">110 110 100</td></tr><tr><td align="center">666</td><td align="center">0002取反</td><td align="center">644</td></tr></tbody></table><h3 id="文件IO与标准IO文件打开模式对照表"><a href="#文件IO与标准IO文件打开模式对照表" class="headerlink" title="文件IO与标准IO文件打开模式对照表"></a><strong>文件IO</strong>与<strong>标准IO</strong>文件打开模式对照表</h3><table><thead><tr><th align="center">文件IO模式</th><th align="center">标准IO模式</th></tr></thead><tbody><tr><td align="center">O_RDONLY</td><td align="center">“r”</td></tr><tr><td align="center">O_RDWR</td><td align="center">“r+”</td></tr><tr><td align="center">O_WEONLY &#124; O_CREATE &#124; O_TRUNC</td><td align="center">“w”</td></tr><tr><td align="center">O_RDWR &#124; O_TRUNC &#124; O_CREATE</td><td align="center">“w+”</td></tr><tr><td align="center">O_APPEND &#124; O_CREATE &#124; O_WEONLY</td><td align="center">“a”</td></tr><tr><td align="center">O_APPEND &#124; O_CREATE &#124; O_RDWR</td><td align="center">“a+”</td></tr></tbody></table><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><blockquote><p>close()：关闭文件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    一个文件描述符。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>。</span><br><span class="line">    失败：<span class="number">-1</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><blockquote><p>read()：从文件中读取数据，返回读取的字节数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    <span class="number">1.</span> fd：文件描述符。</span><br><span class="line">    <span class="number">2.</span> buf：指向读入数据的缓冲区。</span><br><span class="line">    <span class="number">3.</span> count：要读取的字节数。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：读取的字节数。</span><br><span class="line">    失败：<span class="number">-1</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><blockquote><p>write()：向文件中写入数据，返回写入的字节数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    <span class="number">1.</span> fd：文件描述符。</span><br><span class="line">    <span class="number">2.</span> buf：指向要写入的数据。</span><br><span class="line">    <span class="number">3.</span> count：要写入的元素个数。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：写入元素的个数。</span><br><span class="line">    失败：<span class="number">-1</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="定位文件指针"><a href="#定位文件指针" class="headerlink" title="定位文件指针"></a>定位文件指针</h2><blockquote><p>lseek()：定位文件指针。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    <span class="number">1.</span> fd：文件描述符。</span><br><span class="line">    <span class="number">2.</span> offset：偏移量。</span><br><span class="line">    <span class="number">3.</span> whence：起始位置。</span><br><span class="line">        - SEEK_SET：从文件开头开始。</span><br><span class="line">        - SEEK_CUR：从当前位置开始。</span><br><span class="line">        - SEEK_END：从文件末尾开始。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：新的文件指针位置。</span><br><span class="line">    失败：<span class="number">-1</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件属性获取"><a href="#文件属性获取" class="headerlink" title="文件属性获取"></a>文件属性获取</h2><blockquote><p>stat()：获取文件属性。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br><span class="line">功能：获取文件属性</span><br><span class="line">参数：path：文件路径名</span><br><span class="line">   buf：保存文件属性信息的结构体</span><br><span class="line">返回值：成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>    st_dev;       <span class="comment">/* 设备ID */</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;     <span class="comment">/* inode号 */</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;    <span class="comment">/* 文件类型和权限 */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;   <span class="comment">/* 硬链接数 */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;     <span class="comment">/* 用户ID */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;     <span class="comment">/* 组ID */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;    <span class="comment">/* 大小 */</span></span><br><span class="line">    <span class="type">time_t</span>    st_atime;   <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="type">time_t</span>    st_mtime;   <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="type">time_t</span>    st_ctime;  <span class="comment">/* 最后状态改变时间 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>示例：实现 <code>ls -l 文件名 </code> 命令的功能<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取输入文件的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == __S_IFREG)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == __S_IFDIR)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == __S_IFCHR)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == __S_IFREG)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == __S_IFSOCK)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == __S_IFIFO)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == __S_IFLNK)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件权限</span></span><br><span class="line">    <span class="type">char</span> arr[<span class="number">3</span>] = <span class="string">&quot;rwx&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (st.st_mode &amp; (<span class="number">0400</span> &gt;&gt; i)) ? arr[i % <span class="number">3</span>] : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出文件硬连接数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %ld&quot;</span>, st.st_nlink);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件的用户名和组名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %s &quot;</span>,getpwuid(st.st_uid)-&gt;pw_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %s &quot;</span>,getgrgid(st.st_gid)-&gt;gr_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出文件大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %ld&quot;</span>,st.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件最后修改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">p</span> =</span> localtime(&amp;st.st_mtime);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d %d %d:%d&quot;</span>,p-&gt;tm_mon+<span class="number">1</span>,p-&gt;tm_mday,p-&gt;tm_hour,p-&gt;tm_min);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出文件名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准IO</title>
      <link href="/2024/07/27/IO%E8%BF%9B%E7%A8%8B/%E6%A0%87%E5%87%86IO/"/>
      <url>/2024/07/27/IO%E8%BF%9B%E7%A8%8B/%E6%A0%87%E5%87%86IO/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h1><p>在C语言中，标准IO（Standard Input&#x2F;Output）是指程序与用户的交互方式。程序通过标准IO向用户输出信息，或者从用户输入信息。标准IO分为输入输出流，分别对应于程序的输入和输出。输入流用于从用户输入信息，输出流用于向用户输出信息。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h2><p>1.有缓冲区：标准IO流具有缓冲区，通过缓冲区可以减少系统调用次数，提高数据的输入输出效率。</p><p>2.围绕<strong>流</strong>进行操作，流用FILE*来描述，FILE代表的是结构体，描述所操作文件的信息。</p><p>3.无需打开关闭：标准IO流不需要打开关闭，程序可以直接使用，默认打开三个流：标准输入（stdin）、标准输出（stdout）、标准错误（stderr）。</p><h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a><strong>缓冲区</strong></h1><p>缓冲区是指在内存中开辟一块空间，用来暂存输入输出的数据。缓冲区的大小一般为1K(1024)，当输入输出的数据量超过缓冲区大小时，系统会自动将数据写入缓冲区，并等待输出。当缓冲区中的数据被读完时，系统会自动从缓冲区中读取数据。</p><p>计算缓冲区大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">stdout</span>-&gt;_IO_buf_end - <span class="built_in">stdout</span>-&gt;_IO_buf_base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="行缓冲：与终端有关"><a href="#行缓冲：与终端有关" class="headerlink" title="行缓冲：与终端有关"></a>行缓冲：与终端有关</h2><h3 id="刷新缓冲的条件："><a href="#刷新缓冲的条件：" class="headerlink" title="刷新缓冲的条件："></a>刷新缓冲的条件：</h3><blockquote><p>1.缓冲区满时，即缓冲区中的数据已经达到缓冲区的最大容量。</p><p>2.通过换行符（\n）来刷新缓冲区。</p><p>3.程序正常结束时，缓冲区中的数据也会被刷新。</p><p>4.强制刷新缓冲区，即调用fflush()函数来刷新缓冲区。</p></blockquote><h2 id="全缓冲：与文件有关"><a href="#全缓冲：与文件有关" class="headerlink" title="全缓冲：与文件有关"></a>全缓冲：与文件有关</h2><h3 id="刷新缓冲的条件：-1"><a href="#刷新缓冲的条件：-1" class="headerlink" title="刷新缓冲的条件："></a>刷新缓冲的条件：</h3><blockquote><p>1.程序正常结束时，缓冲区中的数据会被刷新。</p><p>2.强制刷新缓冲区，即调用fflush()函数来刷新缓冲区。</p><p>3.缓冲区满时，即缓冲区中的数据已经达到缓冲区的最大容量。</p></blockquote><h2 id="无缓冲"><a href="#无缓冲" class="headerlink" title="无缓冲"></a>无缓冲</h2><p>不使用缓冲区，立即输出。例：标准错误（stderr）</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - filename：要打开的文件名。</span><br><span class="line">  - mode：打开模式</span><br><span class="line">    - r：只读模式。</span><br><span class="line">    - w：只写模式。</span><br><span class="line">    - a：追加模式。</span><br><span class="line">    - r+：读写模式。</span><br><span class="line">    - w+：读写模式。</span><br><span class="line">    - a+：读写模式。</span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功打开文件，返回文件指针；</span><br><span class="line">  - 如果失败，返回<span class="literal">NULL</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功关闭文件，返回<span class="number">0</span>；</span><br><span class="line">  - 如果失败，返回EOF。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="每次一个字符读写："><a href="#每次一个字符读写：" class="headerlink" title="每次一个字符读写："></a>每次一个字符读写：</h3><blockquote><p>fgetc()函数：从文件中读取一个字符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功读取一个字符，返回该字符的ASCII码；</span><br><span class="line">  - 如果到达文件末尾，返回EOF。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>fputc()函数：向文件中写入一个字符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - c：要写入的字符。</span><br><span class="line">  - stream：文件指针。      </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功写入一个字符，返回该字符的ASCII码；</span><br><span class="line">  - 如果写入失败，返回EOF。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="每次读写一串字符："><a href="#每次读写一串字符：" class="headerlink" title="每次读写一串字符："></a>每次读写一串字符：</h3><blockquote><p>fgets()函数：从文件中读取一行字符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - s：存放读入字符的缓冲区。</span><br><span class="line">  - n：缓冲区大小。</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功读取一行字符，返回s；</span><br><span class="line">  - 如果到达文件末尾，返回<span class="literal">NULL</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>fputs()函数：向文件中写入一行字符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - s：要写入的字符串。</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功写入一行字符，返回<span class="number">0</span>；</span><br><span class="line">  - 如果写入失败，返回EOF。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="标准化读入写出"><a href="#标准化读入写出" class="headerlink" title="标准化读入写出"></a>标准化读入写出</h3><p>与标准输入输出差异不大，只是多了一个文件流参数。</p><blockquote><p>fscanf()函数：从文件中读取格式化输入。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。</span><br><span class="line">  - format：格式字符串。</span><br><span class="line">  - ...：可变参数，用于存放读入的数据。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功读取格式化输入，返回读取的元素个数；</span><br><span class="line">  - 如果到达文件末尾，返回EOF。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>fprintf()函数：向文件中写入格式化输出。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。</span><br><span class="line">  - format：格式字符串。</span><br><span class="line">  - ...：可变参数，用于存放输出的数据。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功写入格式化输出，返回写入的字符个数；</span><br><span class="line">  - 如果写入失败，返回EOF。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h3><blockquote><p>fread()函数：从文件中读取二进制数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - ptr：存放读入数据的缓冲区。</span><br><span class="line">  - size：每个数据项的大小。</span><br><span class="line">  - nmemb：要读取的数据项个数。</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功读取数据，返回实际读取的元素个数；</span><br><span class="line">  - 如果到达文件末尾，返回<span class="number">0</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>fwrite()函数：向文件中写入二进制数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - ptr：存放输出数据的缓冲区。</span><br><span class="line">  - size：每个数据项的大小。</span><br><span class="line">  - nmemb：要写入的数据项个数。</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功写入数据，返回实际写入的元素个数；</span><br><span class="line">  - 如果写入失败，返回<span class="number">0</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="定位文件位置"><a href="#定位文件位置" class="headerlink" title="定位文件位置"></a>定位文件位置</h2><blockquote><p>fseek()函数：定位文件位置。<strong>注意</strong>：该函数不能在“a”、“a+”模式下使用。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。</span><br><span class="line">  - offset：偏移量。</span><br><span class="line">  - whence：</span><br><span class="line">    - SEEK_SET：从文件开头定位。</span><br><span class="line">    - SEEK_CUR：从当前位置定位。</span><br><span class="line">    - SEEK_END：从文件末尾定位。</span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功定位，返回<span class="number">0</span>；</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>ftell()函数：获取文件位置。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功获取位置，返回当前位置；</span><br><span class="line">  - 如果失败，返回<span class="number">-1</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>rewind()函数：重置文件位置，也就是将文件指针指向文件开头。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以通过fseek()和ftell()函数来实现文件计算文件字符个数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="type">int</span> file_size = ftell(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件大小为：%d\n&quot;</span>, file_size);</span><br></pre></td></tr></table></figure><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><blockquote><p>feof()函数：判断文件是否到达末尾。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果到达文件末尾，返回非<span class="number">0</span>值；</span><br><span class="line">  - 如果未到达文件末尾，返回<span class="number">0</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>ferror()函数：判断文件是否出错。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果文件出错，返回非<span class="number">0</span>值；</span><br><span class="line">  - 如果文件未出错，返回<span class="number">0</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>feof()函数：判断文件是否到达末尾。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - stream：文件指针。  </span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果到达文件末尾，返回非<span class="number">0</span>值；</span><br><span class="line">  - 如果未到达文件末尾，返回<span class="number">0</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以这两个函数来判断文件停止读写时的状态（出错或到达文件末尾）。</p><h2 id="重定向打开文件"><a href="#重定向打开文件" class="headerlink" title="重定向打开文件"></a>重定向打开文件</h2><blockquote><p>freopen()函数：打开一个文件，并将其与一个现有流进行关联。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line">  - filename：要打开的文件名。</span><br><span class="line">  - mode：打开模式。</span><br><span class="line">  - stream：现有流。</span><br><span class="line">- 返回值：</span><br><span class="line">  - 如果成功打开文件，返回文件指针；</span><br><span class="line">  - 如果失败，返回<span class="literal">NULL</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：将标准输出重定向到文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>标准IO流是C语言中最常用的输入输出方式，它提供了一系列的函数来操作文件，包括读写、定位、状态等。缓冲区是标准IO流的重要组成部分，它可以提高数据的输入输出效率，但也会影响程序的运行效率。</p>]]></content>
      
      
      <categories>
          
          <category> IO进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅学一下Markdown</title>
      <link href="/2024/07/20/Markdown%E7%9A%84%E5%85%A5%E9%97%A8/"/>
      <url>/2024/07/20/Markdown%E7%9A%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。<br>Markdown 的语法简洁，只需十个不到的标记符号，就能让人优雅地沉浸式记录，达到「心中无尘，码字入神」的境界。</p><h1 id="Markdown的基本语法"><a href="#Markdown的基本语法" class="headerlink" title="Markdown的基本语法"></a>Markdown的基本语法</h1><h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><p>要创建标题的话，只需在标题文字前面加上 1-6 个 # 号，对应到标题的级别。<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><br>当然这不是唯一的标题语法，还有一些其他的语法，比如在文本下添加若干个“&#x3D;&#x3D;”来标识一级标题，或者“–”来标识二级标题。<br>过要记得在标题文字后面加上空行，否则可能导致标题被当成普通段落处理。‘#’标题之间也需要一个空格。</p><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><p>Markdown 支持有序列表和无序列表。</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>创建有序列表只需要在每个列表项前加上数字和一个点。数字不用有序但要从一开始才会有序。（可以自行试验）</p><ol><li>第一项</li><li>第二项</li><li>第三项</li><li>第四项</li></ol><p>当然也可以进行嵌套，只需要在子列表前面缩进一个或多个空格。</p><ol><li>第一项</li><li>第二项<ul><li>第一项嵌套</li><li>第二项嵌套</li></ul></li><li>第三项</li><li>第四项</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。<br>缩进一个或多个列表项可创建嵌套列表。（就不演示了）</p><h3 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a>在列表中嵌套其他元素</h3><p>Markdown 支持在列表项中嵌套其他元素，包括标题、链接、图片、代码块、粗体、斜体等。</p><h2 id="代码语法"><a href="#代码语法" class="headerlink" title="代码语法"></a>代码语法</h2><p>要将单词或短语表示为代码，请将其包裹在反引号中。就像<code>这样</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言线性表</title>
      <link href="/2024/07/20/C%E8%AF%AD%E8%A8%80%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2024/07/20/C%E8%AF%AD%E8%A8%80%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
